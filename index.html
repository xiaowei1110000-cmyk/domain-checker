<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸŒ ä¸“ä¸šåŸŸåæ•…éšœè¯Šæ–­ç³»ç»Ÿ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #4f46e5 0%, #7e22ce 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .header p {
            opacity: 0.9;
            font-size: 1.1em;
        }
        
        .input-section {
            padding: 40px;
            background: #f8fafc;
        }
        
        .input-group {
            display: flex;
            gap: 10px;
            max-width: 600px;
            margin: 0 auto 20px;
        }
        
        input {
            flex: 1;
            padding: 15px 20px;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            font-size: 16px;
        }
        
        input:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }
        
        button {
            background: linear-gradient(135deg, #4f46e5 0%, #7e22ce 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(79, 70, 229, 0.3);
        }
        
        .test-selection {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 10px;
            max-width: 600px;
            margin: 0 auto;
        }
        
        .test-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px;
            background: white;
            border-radius: 8px;
            cursor: pointer;
        }
        
        .test-checkbox input {
            width: auto;
        }
        
        .results {
            padding: 0 40px 40px;
        }
        
        .test-item {
            background: white;
            border-radius: 10px;
            padding: 25px;
            margin-bottom: 20px;
            border: 1px solid #e2e8f0;
            border-left: 5px solid #e2e8f0;
            transition: all 0.3s;
        }
        
        .test-item.success {
            border-left-color: #10b981;
            background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
        }
        
        .test-item.error {
            border-left-color: #ef4444;
            background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%);
        }
        
        .test-item.warning {
            border-left-color: #f59e0b;
            background: linear-gradient(135deg, #fffbeb 0%, #fef3c7 100%);
        }
        
        .test-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .test-title {
            font-size: 18px;
            font-weight: 600;
            color: #1e293b;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .test-status {
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
        }
        
        .status-success {
            background: #d1fae5;
            color: #065f46;
        }
        
        .status-error {
            background: #fee2e2;
            color: #991b1b;
        }
        
        .status-warning {
            background: #fef3c7;
            color: #92400e;
        }
        
        .test-details {
            color: #475569;
            line-height: 1.6;
            font-family: 'Consolas', 'Monaco', monospace;
            background: rgba(255,255,255,0.7);
            padding: 20px;
            border-radius: 8px;
            margin-top: 15px;
            font-size: 14px;
            white-space: pre-wrap;
            word-break: break-all;
        }
        
        .summary {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 30px;
        }
        
        .summary h3 {
            font-size: 20px;
            margin-bottom: 15px;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #64748b;
            display: none;
        }
        
        .loading-spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #4f46e5;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .error-list {
            background: #fef2f2;
            border: 2px solid #ef4444;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .error-item {
            padding: 10px;
            margin: 5px 0;
            background: white;
            border-radius: 5px;
            border-left: 4px solid #ef4444;
        }
        
        .recommendations {
            background: #dbeafe;
            border: 2px solid #3b82f6;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .port-results {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }
        
        .port-item {
            padding: 10px;
            text-align: center;
            border-radius: 8px;
            font-weight: 600;
        }
        
        .port-open {
            background: #d1fae5;
            color: #065f46;
        }
        
        .port-closed {
            background: #fee2e2;
            color: #991b1b;
        }
        
        .dns-record-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        
        .dns-record-table th, .dns-record-table td {
            border: 1px solid #e2e8f0;
            padding: 10px;
            text-align: left;
        }
        
        .dns-record-table th {
            background-color: #f8fafc;
            font-weight: 600;
        }
        
        @media (max-width: 768px) {
            .container {
                border-radius: 10px;
            }
            
            .header, .input-section, .results {
                padding: 20px;
            }
            
            .input-group {
                flex-direction: column;
            }
            
            button {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ” ä¸“ä¸šåŸŸåæ•…éšœè¯Šæ–­ç³»ç»Ÿ</h1>
            <p>ç²¾ç¡®æ£€æµ‹åŸŸåæ— æ³•è®¿é—®çš„å…·ä½“åŸå›  | WHOISæŸ¥è¯¢ | ç«¯å£æ‰«æ | SSLåˆ†æ | DNSæ·±åº¦è§£æ</p>
        </div>
        
        <div class="input-section">
            <div class="input-group">
                <input type="text" id="domainInput" 
                       placeholder="è¾“å…¥è¦è¯Šæ–­çš„åŸŸåï¼ˆä¾‹å¦‚ï¼šexample.comï¼‰" 
                       value="baidu.com">
                <button id="diagnoseBtn" onclick="startDiagnosis()">å¼€å§‹å…¨é¢è¯Šæ–­</button>
            </div>
            
            <div class="test-selection">
                <label class="test-checkbox">
                    <input type="checkbox" id="checkDNS" checked> ğŸŒ DNSè§£ææ£€æµ‹
                </label>
                <label class="test-checkbox">
                    <input type="checkbox" id="checkDNSFull" checked> ğŸ” å®Œæ•´DNSè§£æï¼ˆå¢å¼ºï¼‰
                </label>
                <label class="test-checkbox">
                    <input type="checkbox" id="checkHTTP" checked> ğŸ”— HTTP/HTTPSæ£€æµ‹
                </label>
                <label class="test-checkbox">
                    <input type="checkbox" id="checkSSL" checked> ğŸ”’ SSLè¯ä¹¦æ£€æµ‹
                </label>
                <label class="test-checkbox">
                    <input type="checkbox" id="checkPorts" checked> ğŸšª ç«¯å£æ£€æµ‹
                </label>
                <label class="test-checkbox">
                    <input type="checkbox" id="checkWHOIS" checked> ğŸ“‹ WHOISä¿¡æ¯
                </label>
                <label class="test-checkbox">
                    <input type="checkbox" id="checkPing" checked> ğŸ“¡ Pingæµ‹è¯•
                </label>
            </div>
            
            <div id="errorMessage" style="display:none;color:#ef4444;text-align:center;margin-top:10px;"></div>
        </div>
        
        <div class="results" id="resultsContainer">
            <div class="loading" id="loading">
                <div class="loading-spinner"></div>
                <p>æ­£åœ¨æ‰§è¡Œæ·±åº¦è¯Šæ–­ï¼Œè¯·ç¨å€™...</p>
            </div>
            <!-- ç»“æœå°†åŠ¨æ€ç”Ÿæˆ -->
        </div>
    </div>

    <script>
        // ä½¿ç”¨è‡ªå·±çš„ä»£ç†æœåŠ¡å™¨ç»•è¿‡CORSï¼ˆç¤ºä¾‹ç”¨ï¼Œå®é™…éœ€è¦éƒ¨ç½²ï¼‰
        const PROXY_URL = 'https://cors-anywhere.herokuapp.com/';
        
        class ProfessionalDomainDiagnostic {
            constructor() {
                this.domain = '';
                this.results = {};
                this.errors = [];
                this.recommendations = [];
            }
            
            async startDiagnosis(domain) {
                this.domain = domain;
                this.results = {};
                this.errors = [];
                this.recommendations = [];
                
                // æ˜¾ç¤ºåŠ è½½
                document.getElementById('loading').style.display = 'block';
                document.getElementById('resultsContainer').innerHTML = '';
                
                try {
                    // æ‰§è¡Œæ‰€æœ‰é€‰ä¸­çš„æ£€æµ‹
                    const checks = [];
                    
                    if (document.getElementById('checkDNS').checked) {
                        checks.push(this.checkDNS());
                    }
                    
                    if (document.getElementById('checkDNSFull').checked) {
                        checks.push(this.fullDNSLookup());
                    }
                    
                    if (document.getElementById('checkHTTP').checked) {
                        checks.push(this.checkHTTP());
                    }
                    
                    if (document.getElementById('checkSSL').checked) {
                        checks.push(this.checkSSL());
                    }
                    
                    if (document.getElementById('checkPorts').checked) {
                        checks.push(this.checkPorts());
                    }
                    
                    if (document.getElementById('checkWHOIS').checked) {
                        checks.push(this.checkWHOIS());
                    }
                    
                    if (document.getElementById('checkPing').checked) {
                        checks.push(this.checkPing());
                    }
                    
                    // ä½¿ç”¨Promise.allSettledæ¥é¿å…å•ä¸ªå¤±è´¥å½±å“å…¨éƒ¨
                    const results = await Promise.allSettled(checks);
                    
                    // å¤„ç†ç»“æœ
                    results.forEach((result, index) => {
                        if (result.status === 'fulfilled') {
                            const [key, data] = Object.entries(result.value)[0];
                            this.results[key] = data;
                        } else {
                            console.error('æ£€æµ‹å¤±è´¥:', result.reason);
                        }
                    });
                    
                    // åˆ†ææ•…éšœåŸå› 
                    this.analyzeFaults();
                    
                    // æ˜¾ç¤ºç»“æœ
                    this.displayResults();
                    
                } catch (error) {
                    console.error('è¯Šæ–­å¤±è´¥:', error);
                    document.getElementById('errorMessage').textContent = `è¯Šæ–­å¤±è´¥: ${error.message}`;
                    document.getElementById('errorMessage').style.display = 'block';
                } finally {
                    document.getElementById('loading').style.display = 'none';
                }
            }
            
            // 1. åŸºç¡€DNSæ£€æµ‹
            async checkDNS() {
                try {
                    // ä½¿ç”¨Cloudflareçš„DNS-over-HTTPS
                    const response = await fetch(
                        `https://cloudflare-dns.com/dns-query?name=${this.domain}&type=A`,
                        { 
                            headers: { 'Accept': 'application/dns-json' }
                        }
                    );
                    
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    
                    const data = await response.json();
                    
                    let status = 'success';
                    let details = `ğŸ” DNSè§£ææŸ¥è¯¢ç»“æœ:\n\n`;
                    
                    if (data.Status === 0 && data.Answer && data.Answer.length > 0) {
                        const ips = data.Answer.map(a => `${a.data} (TTL: ${a.TTL}s)`).join('\n');
                        details += `âœ… Aè®°å½•è§£ææˆåŠŸ:\n${ips}\n`;
                        
                        // ä¿å­˜IPä¾›å…¶ä»–æ£€æµ‹ä½¿ç”¨
                        this.ips = data.Answer.map(a => a.data);
                        
                        // æ£€æŸ¥CDN
                        if (data.Answer.length > 1) {
                            details += `ğŸ”€ æ£€æµ‹åˆ°${data.Answer.length}ä¸ªIPï¼Œå¯èƒ½ä½¿ç”¨CDNæˆ–è´Ÿè½½å‡è¡¡\n`;
                        }
                        
                    } else if (data.Answer && data.Answer.length === 0) {
                        status = 'error';
                        details += `âŒ æ²¡æœ‰æ‰¾åˆ°Aè®°å½•\n`;
                        this.errors.push('DNS Aè®°å½•ä¸å­˜åœ¨');
                    } else {
                        status = 'error';
                        details += `âŒ DNSè§£æå¤±è´¥ (çŠ¶æ€ç : ${data.Status})\n`;
                        this.errors.push('DNSè§£æå¤±è´¥');
                    }
                    
                    return { dns: { status, details, raw: data } };
                    
                } catch (error) {
                    return { 
                        dns: { 
                            status: 'error', 
                            details: `DNSæŸ¥è¯¢å¤±è´¥: ${error.message}\n\nè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–åŸŸåæ˜¯å¦æ­£ç¡®ã€‚` 
                        } 
                    };
                }
            }
            
            // 2. å®Œæ•´çš„DNSè§£ææŸ¥è¯¢ï¼ˆæ¯”nslookupæ›´è¯¦ç»†ï¼‰
            async fullDNSLookup() {
                try {
                    let details = `ğŸ”¬ å®Œæ•´DNSè§£æè®°å½• (æ¯”nslookupæ›´è¯¦ç»†):\n\n`;
                    
                    // æŸ¥è¯¢å¤šç§DNSè®°å½•ç±»å‹
                    const recordTypes = [
                        { type: 'A', name: 'Aè®°å½• (IPv4åœ°å€)' },
                        { type: 'AAAA', name: 'AAAAè®°å½• (IPv6åœ°å€)' },
                        { type: 'CNAME', name: 'CNAMEè®°å½• (åˆ«å)' },
                        { type: 'MX', name: 'MXè®°å½• (é‚®ä»¶æœåŠ¡å™¨)' },
                        { type: 'TXT', name: 'TXTè®°å½• (æ–‡æœ¬è®°å½•)' },
                        { type: 'NS', name: 'NSè®°å½• (åŸŸåæœåŠ¡å™¨)' },
                        { type: 'SOA', name: 'SOAè®°å½• (æˆæƒèµ·å§‹)' },
                        { type: 'SRV', name: 'SRVè®°å½• (æœåŠ¡è®°å½•)' },
                        { type: 'CAA', name: 'CAAè®°å½• (è¯ä¹¦é¢å‘)' }
                    ];
                    
                    const records = [];
                    
                    // å¹¶è¡ŒæŸ¥è¯¢æ‰€æœ‰è®°å½•ç±»å‹
                    const queries = recordTypes.map(async ({ type, name }) => {
                        try {
                            const response = await fetch(
                                `https://cloudflare-dns.com/dns-query?name=${this.domain}&type=${type}`,
                                { headers: { 'Accept': 'application/dns-json' } }
                            );
                            
                            if (response.ok) {
                                const data = await response.json();
                                
                                if (data.Status === 0 && data.Answer && data.Answer.length > 0) {
                                    const recordDetails = data.Answer.map(record => {
                                        let line = `  â€¢ ${record.data}`;
                                        if (record.TTL) line += ` (TTL: ${record.TTL}s)`;
                                        if (type === 'MX') line = `  â€¢ ä¼˜å…ˆçº§: ${record.data.split(' ')[0]}, æœåŠ¡å™¨: ${record.data.split(' ')[1]}`;
                                        return line;
                                    }).join('\n');
                                    
                                    records.push({
                                        type,
                                        name,
                                        count: data.Answer.length,
                                        details: recordDetails,
                                        raw: data.Answer
                                    });
                                }
                            }
                        } catch (error) {
                            // æŸäº›è®°å½•ç±»å‹å¯èƒ½ä¸å­˜åœ¨ï¼Œå¿½ç•¥é”™è¯¯
                        }
                    });
                    
                    await Promise.allSettled(queries);
                    
                    // æ˜¾ç¤ºè¡¨æ ¼æ ¼å¼çš„ç»“æœ
                    if (records.length > 0) {
                        details += '<table class="dns-record-table">';
                        details += '<tr><th>è®°å½•ç±»å‹</th><th>æ•°é‡</th><th>è¯¦ç»†å€¼</th></tr>';
                        
                        records.forEach(record => {
                            details += `<tr>
                                <td><strong>${record.name}</strong></td>
                                <td>${record.count}</td>
                                <td>${record.details.replace(/\n/g, '<br>')}</td>
                            </tr>`;
                        });
                        
                        details += '</table>';
                        
                        // åˆ†æç»“æœ
                        const hasIPv6 = records.some(r => r.type === 'AAAA');
                        const hasMX = records.some(r => r.type === 'MX');
                        const hasTXT = records.some(r => r.type === 'TXT');
                        
                        details += '\nğŸ“Š DNSé…ç½®åˆ†æ:\n';
                        if (hasIPv6) details += 'âœ… æ”¯æŒIPv6\n';
                        else details += 'âš ï¸ æœªé…ç½®IPv6åœ°å€\n';
                        
                        if (hasMX) details += 'âœ… é‚®ä»¶æœåŠ¡å™¨é…ç½®æ­£å¸¸\n';
                        else details += 'âš ï¸ æœªé…ç½®é‚®ä»¶æœåŠ¡å™¨(MXè®°å½•)\n';
                        
                        if (hasTXT) details += 'âœ… å­˜åœ¨TXTè®°å½•ï¼ˆå¯èƒ½ç”¨äºéªŒè¯æˆ–å®‰å…¨ç­–ç•¥ï¼‰\n';
                        
                        // æ£€æŸ¥å¸¸è§çš„DNSå®‰å…¨é—®é¢˜
                        const hasCAA = records.some(r => r.type === 'CAA');
                        if (!hasCAA) {
                            details += 'âš ï¸ å»ºè®®é…ç½®CAAè®°å½•ä»¥é™åˆ¶SSLè¯ä¹¦é¢å‘\n';
                            this.recommendations.push('é…ç½®CAAè®°å½•å¢å¼ºå®‰å…¨æ€§');
                        }
                        
                    } else {
                        details += 'âŒ æœªæŸ¥è¯¢åˆ°ä»»ä½•DNSè®°å½•\n';
                        status = 'error';
                        this.errors.push('DNSè®°å½•æŸ¥è¯¢å¤±è´¥');
                    }
                    
                    // å°è¯•æŸ¥è¯¢DNSSECä¿¡æ¯
                    try {
                        const dnssecResponse = await fetch(
                            `https://dns.google/resolve?name=${this.domain}&type=DNSKEY`,
                            { headers: { 'Accept': 'application/dns-json' } }
                        );
                        
                        if (dnssecResponse.ok) {
                            const dnssecData = await dnssecResponse.json();
                            if (dnssecData.Answer && dnssecData.Answer.length > 0) {
                                details += '\nğŸ” DNSSEC: âœ… å·²å¯ç”¨ï¼ˆåŸŸåç³»ç»Ÿå®‰å…¨æ‰©å±•ï¼‰\n';
                            } else {
                                details += '\nğŸ” DNSSEC: âŒ æœªå¯ç”¨ï¼ˆå»ºè®®å¯ç”¨å¢å¼ºå®‰å…¨æ€§ï¼‰\n';
                                this.recommendations.push('è€ƒè™‘å¯ç”¨DNSSEC');
                            }
                        }
                    } catch (dnssecError) {
                        details += '\nğŸ” DNSSEC: âš ï¸ æ£€æµ‹å¤±è´¥\n';
                    }
                    
                    return { dnsFull: { status: 'success', details, records } };
                    
                } catch (error) {
                    return { 
                        dnsFull: { 
                            status: 'error', 
                            details: `å®Œæ•´DNSæŸ¥è¯¢å¤±è´¥: ${error.message}` 
                        } 
                    };
                }
            }
            
            // 3. HTTP/HTTPSæ£€æµ‹ï¼ˆä½¿ç”¨ä»£ç†ç»•è¿‡CORSï¼‰
            async checkHTTP() {
                try {
                    const results = {};
                    let details = '';
                    
                    // æ£€æµ‹HTTPS
                    try {
                        const startTime = Date.now();
                        // ä½¿ç”¨ä»£ç†æœåŠ¡å™¨ç»•è¿‡CORS
                        const response = await fetch(`${PROXY_URL}https://${this.domain}`, {
                            method: 'HEAD',
                            mode: 'cors',
                            cache: 'no-store'
                        });
                        const time = Date.now() - startTime;
                        
                        results.https = { 
                            success: response.ok, 
                            time, 
                            status: response.status,
                            statusText: response.statusText
                        };
                        
                        details += `ğŸ”’ HTTPSæ£€æµ‹:\n`;
                        details += `  âœ… çŠ¶æ€: ${response.status} ${response.statusText}\n`;
                        details += `  â±ï¸ å“åº”æ—¶é—´: ${time}ms\n`;
                        
                        if (time > 1000) {
                            details += `  âš ï¸ å“åº”è¾ƒæ…¢ï¼Œå»ºè®®ä¼˜åŒ–\n`;
                        }
                        
                    } catch (error) {
                        results.https = { success: false, error: error.message };
                        details += `ğŸ”’ HTTPSæ£€æµ‹:\n  âŒ è¿æ¥å¤±è´¥: ${error.message}\n`;
                        this.errors.push('HTTPSè¿æ¥å¤±è´¥');
                    }
                    
                    // æ£€æµ‹HTTP
                    try {
                        const startTime = Date.now();
                        const response = await fetch(`${PROXY_URL}http://${this.domain}`, {
                            method: 'HEAD',
                            mode: 'cors',
                            cache: 'no-store'
                        });
                        const time = Date.now() - startTime;
                        
                        results.http = { 
                            success: response.ok, 
                            time, 
                            status: response.status,
                            statusText: response.statusText
                        };
                        
                        details += `\nğŸŒ HTTPæ£€æµ‹:\n`;
                        details += `  âœ… çŠ¶æ€: ${response.status} ${response.statusText}\n`;
                        details += `  â±ï¸ å“åº”æ—¶é—´: ${time}ms\n`;
                        
                        // æ£€æŸ¥æ˜¯å¦é‡å®šå‘åˆ°HTTPS
                        if (response.redirected) {
                            details += `  â†ªï¸ å·²é‡å®šå‘åˆ°HTTPS\n`;
                        }
                        
                    } catch (error) {
                        results.http = { success: false, error: error.message };
                        details += `\nğŸŒ HTTPæ£€æµ‹:\n  âŒ è¿æ¥å¤±è´¥: ${error.message}\n`;
                        this.errors.push('HTTPè¿æ¥å¤±è´¥');
                    }
                    
                    // åˆ†æç»“æœ
                    const status = results.https.success || results.http.success ? 'success' : 'error';
                    
                    if (!results.https.success && !results.http.success) {
                        details += `\nğŸ”´ æ•…éšœåˆ†æ:\n`;
                        details += `  â€¢ æœåŠ¡å™¨å¯èƒ½å®•æœºæˆ–ç½‘ç»œä¸å¯è¾¾\n`;
                        details += `  â€¢ é˜²ç«å¢™å¯èƒ½é˜»æ­¢äº†è¿æ¥\n`;
                        details += `  â€¢ åŸŸåå¯èƒ½è§£æåˆ°é”™è¯¯çš„IP\n`;
                    } else if (!results.https.success && results.http.success) {
                        details += `\nâš ï¸ æ³¨æ„:\n`;
                        details += `  â€¢ HTTPæ­£å¸¸ä½†HTTPSå¤±è´¥\n`;
                        details += `  â€¢ å¯èƒ½SSLè¯ä¹¦é…ç½®æœ‰é—®é¢˜\n`;
                        this.recommendations.push('ä¿®å¤HTTPSé…ç½®æˆ–SSLè¯ä¹¦');
                    }
                    
                    return { http: { status, details, results } };
                    
                } catch (error) {
                    return { 
                        http: { 
                            status: 'error', 
                            details: `HTTP/HTTPSæ£€æµ‹å¤±è´¥: ${error.message}` 
                        } 
                    };
                }
            }
            
            // 4. SSLè¯ä¹¦æ£€æµ‹ï¼ˆä½¿ç”¨å…¬å¼€APIï¼‰
            async checkSSL() {
                try {
                    // ä½¿ç”¨åœ¨çº¿SSLæ£€æŸ¥API
                    const response = await fetch(`${PROXY_URL}https://api.ssllabs.com/api/v3/analyze?host=${this.domain}&publish=off`);
                    
                    if (!response.ok) {
                        throw new Error('SSL Labs APIè¯·æ±‚å¤±è´¥');
                    }
                    
                    const data = await response.json();
                    
                    let details = `ğŸ” SSLè¯ä¹¦æ£€æµ‹ç»“æœ:\n\n`;
                    
                    if (data.status === 'READY' && data.endpoints && data.endpoints.length > 0) {
                        const endpoint = data.endpoints[0];
                        
                        details += `âœ… æœåŠ¡å™¨: ${endpoint.serverName || this.domain}\n`;
                        details += `ğŸ“Š SSLè¯„çº§: ${endpoint.grade || 'æœªçŸ¥'}\n`;
                        details += `ğŸ”’ åè®®æ”¯æŒ: ${endpoint.supportsSSLv2 ? 'SSLv2, ' : ''}${endpoint.supportsSSLv3 ? 'SSLv3, ' : ''}${endpoint.supportsTLS_1_0 ? 'TLS 1.0, ' : ''}${endpoint.supportsTLS_1_1 ? 'TLS 1.1, ' : ''}${endpoint.supportsTLS_1_2 ? 'TLS 1.2' : ''}\n`;
                        
                        if (endpoint.grade && endpoint.grade === 'A' || endpoint.grade === 'A+') {
                            details += `ğŸ‰ SSLé…ç½®ä¼˜ç§€\n`;
                        } else if (endpoint.grade === 'B' || endpoint.grade === 'C') {
                            details += `âš ï¸ SSLé…ç½®éœ€è¦æ”¹è¿›\n`;
                            this.recommendations.push('ä¼˜åŒ–SSLé…ç½®æé«˜å®‰å…¨æ€§');
                        } else if (endpoint.grade === 'F' || endpoint.grade === 'T') {
                            details += `âŒ SSLé…ç½®å­˜åœ¨ä¸¥é‡é—®é¢˜\n`;
                            this.errors.push('SSLè¯ä¹¦é…ç½®ä¸å®‰å…¨');
                        }
                        
                        // æ£€æŸ¥è¯ä¹¦æœ‰æ•ˆæœŸ
                        if (endpoint.certificate && endpoint.certificate.notAfter) {
                            const expiryDate = new Date(endpoint.certificate.notAfter);
                            const now = new Date();
                            const daysLeft = Math.ceil((expiryDate - now) / (1000 * 60 * 60 * 24));
                            
                            details += `ğŸ“… è¯ä¹¦è¿‡æœŸæ—¶é—´: ${expiryDate.toLocaleDateString()}\n`;
                            details += `â³ å‰©ä½™å¤©æ•°: ${daysLeft}å¤©\n`;
                            
                            if (daysLeft < 30) {
                                details += `âš ï¸ è¯ä¹¦å³å°†è¿‡æœŸï¼Œè¯·å°½å¿«ç»­æœŸï¼\n`;
                                this.errors.push('SSLè¯ä¹¦å³å°†è¿‡æœŸ');
                                this.recommendations.push('ç«‹å³ç»­æœŸSSLè¯ä¹¦');
                            }
                        }
                        
                    } else {
                        details += `â„¹ï¸ SSLä¿¡æ¯æ­£åœ¨åˆ†æä¸­...\n`;
                        details += `å®Œæ•´æŠ¥å‘Šè¯·è®¿é—®: https://www.ssllabs.com/ssltest/analyze.html?d=${this.domain}\n`;
                    }
                    
                    return { ssl: { status: 'success', details, raw: data } };
                    
                } catch (error) {
                    // å¤‡ç”¨æ£€æµ‹æ–¹æ³•
                    let details = `ğŸ” SSLè¯ä¹¦æ£€æµ‹ï¼ˆç®€åŒ–ï¼‰:\n\n`;
                    
                    try {
                        // å°è¯•ç›´æ¥è¿æ¥è·å–è¯ä¹¦ä¿¡æ¯
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 5000);
                        
                        const response = await fetch(`https://${this.domain}`, {
                            signal: controller.signal,
                            mode: 'no-cors'
                        });
                        
                        clearTimeout(timeoutId);
                        
                        details += `âœ… HTTPSè¿æ¥æˆåŠŸ\n`;
                        details += `ğŸ”’ åŸºæœ¬SSLåŠŸèƒ½æ­£å¸¸\n`;
                        details += `âš ï¸ è¯¦ç»†è¯ä¹¦ä¿¡æ¯éœ€è¦å®Œæ•´æ‰«æ\n`;
                        
                        return { ssl: { status: 'success', details } };
                        
                    } catch (sslError) {
                        details += `âŒ SSLè¯ä¹¦æ£€æµ‹å¤±è´¥\n`;
                        details += `å¯èƒ½åŸå› :\n`;
                        details += `  â€¢ ç½‘ç«™æœªå¯ç”¨HTTPS\n`;
                        details += `  â€¢ SSLè¯ä¹¦è¿‡æœŸæˆ–æ— æ•ˆ\n`;
                        details += `  â€¢ è¯ä¹¦é“¾é…ç½®é”™è¯¯\n`;
                        details += `  â€¢ ä¸æ”¯æŒçš„SSL/TLSåè®®\n`;
                        
                        this.errors.push('SSL/TLSè¿æ¥å¤±è´¥');
                        
                        return { ssl: { status: 'error', details } };
                    }
                }
            }
            
            // 5. ç«¯å£æ£€æµ‹ï¼ˆæ¨¡æ‹Ÿï¼‰
            async checkPorts() {
                try {
                    let details = `ğŸšª å¸¸è§æœåŠ¡ç«¯å£çŠ¶æ€:\n\n`;
                    
                    // å¸¸è§ç«¯å£åˆ—è¡¨
                    const commonPorts = [
                        { port: 80, service: 'HTTP', description: 'ç½‘é¡µæœåŠ¡' },
                        { port: 443, service: 'HTTPS', description: 'å®‰å…¨ç½‘é¡µæœåŠ¡' },
                        { port: 21, service: 'FTP', description: 'æ–‡ä»¶ä¼ è¾“' },
                        { port: 22, service: 'SSH', description: 'å®‰å…¨è¿œç¨‹ç™»å½•' },
                        { port: 25, service: 'SMTP', description: 'é‚®ä»¶å‘é€' },
                        { port: 53, service: 'DNS', description: 'åŸŸåè§£æ' },
                        { port: 110, service: 'POP3', description: 'é‚®ä»¶æ¥æ”¶' },
                        { port: 143, service: 'IMAP', description: 'é‚®ä»¶åŒæ­¥' },
                        { port: 3306, service: 'MySQL', description: 'æ•°æ®åº“' },
                        { port: 3389, service: 'RDP', description: 'è¿œç¨‹æ¡Œé¢' },
                        { port: 5432, service: 'PostgreSQL', description: 'æ•°æ®åº“' },
                        { port: 6379, service: 'Redis', description: 'ç¼“å­˜æ•°æ®åº“' },
                        { port: 27017, service: 'MongoDB', description: 'æ•°æ®åº“' }
                    ];
                    
                    details += '<div class="port-results">';
                    
                    // ç”±äºæµè§ˆå™¨é™åˆ¶ï¼Œæˆ‘ä»¬æ— æ³•è¿›è¡ŒçœŸæ­£çš„ç«¯å£æ‰«æ
                    // è¿™é‡ŒåŸºäºHTTPæ£€æµ‹ç»“æœæ¨æ–­
                    const isHTTPSAvailable = this.results.http?.results?.https?.success;
                    const isHTTPAvailable = this.results.http?.results?.http?.success;
                    
                    commonPorts.forEach(portInfo => {
                        let status = 'æœªçŸ¥';
                        let statusClass = 'port-closed';
                        
                        if (portInfo.port === 80 && isHTTPAvailable) {
                            status = 'å¼€æ”¾';
                            statusClass = 'port-open';
                        } else if (portInfo.port === 443 && isHTTPSAvailable) {
                            status = 'å¼€æ”¾';
                            statusClass = 'port-open';
                        }
                        
                        details += `<div class="port-item ${statusClass}">
                            <div>${portInfo.port}</div>
                            <small>${portInfo.service}</small>
                            <div><strong>${status}</strong></div>
                        </div>`;
                    });
                    
                    details += '</div>';
                    
                    details += `\nâš ï¸ æ³¨æ„ï¼šçœŸæ­£çš„ç«¯å£æ‰«æéœ€è¦æœåŠ¡å™¨ç«¯æƒé™\n`;
                    details += `æ¨èä½¿ç”¨: <code>nmap -sS ${this.domain}</code>\n`;
                    
                    return { ports: { status: 'warning', details } };
                    
                } catch (error) {
                    return { 
                        ports: { 
                            status: 'warning', 
                            details: `ç«¯å£æ£€æµ‹å—é™: ${error.message}\n\nç«¯å£æ‰«æéœ€è¦åœ¨æœåŠ¡å™¨ç¯å¢ƒæ‰§è¡Œã€‚` 
                        } 
                    };
                }
            }
            
            // 6. WHOISä¿¡æ¯æŸ¥è¯¢
            async checkWHOIS() {
                try {
                    // ä½¿ç”¨å¤šä¸ªWHOIS APIæºå¢åŠ æˆåŠŸç‡
                    const whoisApis = [
                        `https://api.whois.vu/?domain=${this.domain}`,
                        `https://whois.freeaiapi.xyz/?name=${this.domain}`,
                        `https://api.ip2whois.com/v2?key=demo&domain=${this.domain}`
                    ];
                    
                    let whoisData = null;
                    
                    for (const apiUrl of whoisApis) {
                        try {
                            const response = await fetch(apiUrl);
                            if (response.ok) {
                                const data = await response.json();
                                whoisData = data;
                                break;
                            }
                        } catch (error) {
                            continue; // å°è¯•ä¸‹ä¸€ä¸ªAPI
                        }
                    }
                    
                    let details = `ğŸ“‹ WHOISåŸŸåæ³¨å†Œä¿¡æ¯:\n\n`;
                    
                    if (whoisData) {
                        // å°è¯•æå–å„ç§å¯èƒ½çš„å­—æ®µå
                        const registrant = whoisData.registrant || whoisData.Registrant || whoisData.owner;
                        const registrar = whoisData.registrar || whoisData.Registrar;
                        const creation = whoisData.creation_date || whoisData.created || whoisData.CreationDate;
                        const expiry = whoisData.expiration_date || whoisData.expires || whoisData.ExpirationDate;
                        const nameservers = whoisData.name_servers || whoisData.nameservers || whoisData.NameServers;
                        
                        if (registrar) details += `ğŸ¢ æ³¨å†Œå•†: ${registrar}\n`;
                        if (registrant) details += `ğŸ‘¤ æ³¨å†Œäºº: ${registrant}\n`;
                        if (creation) {
                            details += `ğŸ“… åˆ›å»ºæ—¶é—´: ${creation}\n`;
                        }
                        if (expiry) {
                            details += `â° è¿‡æœŸæ—¶é—´: ${expiry}\n`;
                            
                            // è®¡ç®—å‰©ä½™å¤©æ•°
                            try {
                                const expDate = new Date(expiry);
                                const now = new Date();
                                const daysLeft = Math.ceil((expDate - now) / (1000 * 60 * 60 * 24));
                                
                                details += `ğŸ“† å‰©ä½™å¤©æ•°: ${daysLeft}å¤©\n`;
                                
                                if (daysLeft < 30) {
                                    details += `âš ï¸ è­¦å‘Š: åŸŸåå°†åœ¨${daysLeft}å¤©åè¿‡æœŸï¼\n`;
                                    this.errors.push('åŸŸåå³å°†è¿‡æœŸ');
                                    this.recommendations.push('ç«‹å³ç»­è´¹åŸŸå');
                                }
                            } catch (dateError) {
                                // æ—¥æœŸè§£æå¤±è´¥ï¼Œå¿½ç•¥
                            }
                        }
                        
                        if (nameservers) {
                            const nsList = Array.isArray(nameservers) ? nameservers.join(', ') : nameservers;
                            details += `ğŸŒ DNSæœåŠ¡å™¨: ${nsList}\n`;
                        }
                        
                        if (whoisData.status) {
                            const statusList = Array.isArray(whoisData.status) ? whoisData.status.join(', ') : whoisData.status;
                            details += `ğŸ“Š çŠ¶æ€: ${statusList}\n`;
                        }
                        
                    } else {
                        details += `â„¹ï¸ WHOISä¿¡æ¯è·å–å—é™\n`;
                        details += `å®Œæ•´ä¿¡æ¯å»ºè®®è®¿é—®:\n`;
                        details += `â€¢ https://whois.icann.org/zh/lookup?name=${this.domain}\n`;
                        details += `â€¢ https://whois.chinaz.com/${this.domain}\n`;
                        details += `â€¢ å‘½ä»¤è¡Œ: <code>whois ${this.domain}</code>\n`;
                    }
                    
                    return { whois: { status: 'success', details, raw: whoisData } };
                    
                } catch (error) {
                    let details = `âŒ WHOISæŸ¥è¯¢å¤±è´¥\n`;
                    details += `å¯èƒ½åŸå› :\n`;
                    details += `â€¢ WHOISæœåŠ¡å™¨é™åˆ¶æˆ–è¶…æ—¶\n`;
                    details += `â€¢ åŸŸåæ³¨å†Œä¿¡æ¯éšç§ä¿æŠ¤\n`;
                    details += `\næ›¿ä»£æ–¹æ¡ˆ:\n`;
                    details += `â€¢ è®¿é—® https://whois.icann.org\n`;
                    details += `â€¢ ä½¿ç”¨å‘½ä»¤è¡Œ: whois ${this.domain}\n`;
                    
                    return { whois: { status: 'warning', details } };
                }
            }
            
            // 7. Pingæµ‹è¯•ï¼ˆç½‘ç»œè¿é€šæ€§ï¼‰
            async checkPing() {
                try {
                    // ä½¿ç”¨å¤šä¸ªç«¯ç‚¹è¿›è¡Œæµ‹è¯•
                    const testUrls = [
                        `https://${this.domain}/favicon.ico`,
                        `https://${this.domain}/robots.txt`,
                        `https://${this.domain}`
                    ];
                    
                    let fastestTime = Infinity;
                    let slowestTime = 0;
                    let totalTime = 0;
                    let successCount = 0;
                    
                    details = `ğŸ“¡ ç½‘ç»œè¿é€šæ€§æµ‹è¯•:\n\n`;
                    
                    for (const url of testUrls) {
                        try {
                            const startTime = Date.now();
                            const response = await fetch(url, {
                                method: 'HEAD',
                                mode: 'no-cors',
                                cache: 'no-store'
                            });
                            const time = Date.now() - startTime;
                            
                            fastestTime = Math.min(fastestTime, time);
                            slowestTime = Math.max(slowestTime, time);
                            totalTime += time;
                            successCount++;
                            
                            details += `  ${url.replace(`https://${this.domain}`, '')}: ${time}ms\n`;
                            
                        } catch (error) {
                            details += `  ${url.replace(`https://${this.domain}`, '')}: âŒ å¤±è´¥\n`;
                        }
                    }
                    
                    if (successCount > 0) {
                        const avgTime = Math.round(totalTime / successCount);
                        
                        details += `\nğŸ“Š ç»Ÿè®¡ç»“æœ:\n`;
                        details += `  âœ… æˆåŠŸè¿æ¥: ${successCount}/${testUrls.length}\n`;
                        details += `  â±ï¸ å¹³å‡æ—¶é—´: ${avgTime}ms\n`;
                        details += `  ğŸï¸ æœ€å¿«: ${fastestTime}ms\n`;
                        details += `  ğŸ¢ æœ€æ…¢: ${slowestTime}ms\n`;
                        
                        // ç½‘ç»œè´¨é‡è¯„ä¼°
                        let quality = 'ä¼˜ç§€';
                        let qualityColor = 'ğŸŸ¢';
                        
                        if (avgTime > 100) {
                            quality = 'è‰¯å¥½';
                            qualityColor = 'ğŸŸ¡';
                        }
                        if (avgTime > 500) {
                            quality = 'ä¸€èˆ¬';
                            qualityColor = 'ğŸŸ ';
                        }
                        if (avgTime > 1000) {
                            quality = 'è¾ƒå·®';
                            qualityColor = 'ğŸ”´';
                            this.recommendations.push('ä¼˜åŒ–æœåŠ¡å™¨ç½‘ç»œæ€§èƒ½');
                        }
                        if (avgTime > 3000) {
                            quality = 'å¾ˆå·®';
                            qualityColor = 'â›”';
                            this.errors.push('ç½‘ç»œå»¶è¿Ÿè¿‡é«˜');
                        }
                        
                        details += `  ğŸ“ˆ ç½‘ç»œè´¨é‡: ${qualityColor} ${quality}\n`;
                        
                        // ä¸¢åŒ…ç‡æ¨¡æ‹Ÿ
                        const packetLoss = ((testUrls.length - successCount) / testUrls.length * 100).toFixed(1);
                        if (packetLoss > 0) {
                            details += `  ğŸ“‰ æ¨¡æ‹Ÿä¸¢åŒ…ç‡: ${packetLoss}%\n`;
                        }
                        
                        return { ping: { status: 'success', details, stats: { avgTime, fastestTime, slowestTime, successCount } } };
                        
                    } else {
                        details += `\nâŒ æ‰€æœ‰æµ‹è¯•å‡å¤±è´¥\n`;
                        details += `å¯èƒ½åŸå› :\n`;
                        details += `  â€¢ æœåŠ¡å™¨å®Œå…¨ä¸å¯è¾¾\n`;
                        details += `  â€¢ é˜²ç«å¢™é˜»æ­¢äº†æ‰€æœ‰è¿æ¥\n`;
                        details += `  â€¢ DNSè§£æå¤±è´¥\n`;
                        
                        this.errors.push('æœåŠ¡å™¨ç½‘ç»œä¸å¯è¾¾');
                        
                        return { ping: { status: 'error', details } };
                    }
                    
                } catch (error) {
                    return { 
                        ping: { 
                            status: 'error', 
                            details: `ç½‘ç»œè¿é€šæ€§æµ‹è¯•å¤±è´¥: ${error.message}` 
                        } 
                    };
                }
            }
            
            // åˆ†ææ•…éšœåŸå› 
            analyzeFaults() {
                let faultAnalysis = '';
                
                // æ£€æŸ¥DNSé—®é¢˜
                if (this.results.dns?.status === 'error' || this.results.dnsFull?.status === 'error') {
                    faultAnalysis += `ğŸ”´ DNSæ•…éšœåˆ†æ:\n`;
                    faultAnalysis += `   â†’ åŸŸåæ— æ³•è§£æåˆ°IPåœ°å€\n`;
                    faultAnalysis += `   â†’ å¯èƒ½åŸå› : åŸŸåæœªæ³¨å†Œã€DNSé…ç½®é”™è¯¯ã€DNSæœåŠ¡å™¨æ•…éšœ\n`;
                    faultAnalysis += `   â†’ è§£å†³æ–¹æ¡ˆ: æ£€æŸ¥åŸŸåæ³¨å†ŒçŠ¶æ€ã€ä¿®æ”¹DNSè®¾ç½®\n\n`;
                }
                
                // æ£€æŸ¥HTTP/HTTPSé—®é¢˜
                const httpResults = this.results.http?.results;
                if (httpResults) {
                    if (!httpResults.https?.success && !httpResults.http?.success) {
                        faultAnalysis += `ğŸ”´ WebæœåŠ¡æ•…éšœ:\n`;
                        faultAnalysis += `   â†’ HTTPå’ŒHTTPSå‡æ— æ³•è®¿é—®\n`;
                        faultAnalysis += `   â†’ å¯èƒ½åŸå› : æœåŠ¡å™¨å®•æœºã€é˜²ç«å¢™é˜»æ­¢ã€IPåœ°å€é”™è¯¯\n`;
                        faultAnalysis += `   â†’ è§£å†³æ–¹æ¡ˆ: æ£€æŸ¥æœåŠ¡å™¨çŠ¶æ€ã€é˜²ç«å¢™è§„åˆ™ã€IPé…ç½®\n\n`;
                    } else if (!httpResults.https?.success && httpResults.http?.success) {
                        faultAnalysis += `ğŸŸ¡ HTTPSé…ç½®æ•…éšœ:\n`;
                        faultAnalysis += `   â†’ HTTPæ­£å¸¸ä½†HTTPSå¤±è´¥\n`;
                        faultAnalysis += `   â†’ å¯èƒ½åŸå› : SSLè¯ä¹¦è¿‡æœŸã€é…ç½®é”™è¯¯ã€åè®®ä¸æ”¯æŒ\n`;
                        faultAnalysis += `   â†’ è§£å†³æ–¹æ¡ˆ: æ›´æ–°SSLè¯ä¹¦ã€æ£€æŸ¥HTTPSé…ç½®\n\n`;
                    }
                }
                
                // æ£€æŸ¥SSLé—®é¢˜
                if (this.results.ssl?.status === 'error') {
                    faultAnalysis += `ğŸ”´ SSLè¯ä¹¦æ•…éšœ:\n`;
                    faultAnalysis += `   â†’ SSL/TLSè¿æ¥å¤±è´¥\n`;
                    faultAnalysis += `   â†’ å¯èƒ½åŸå› : è¯ä¹¦è¿‡æœŸã€è¯ä¹¦é“¾ä¸å®Œæ•´ã€åè®®è¿‡æ—¶\n`;
                    faultAnalysis += `   â†’ è§£å†³æ–¹æ¡ˆ: æ›´æ–°è¯ä¹¦ã€é…ç½®å®Œæ•´è¯ä¹¦é“¾ã€å¯ç”¨TLS 1.2+\n\n`;
                }
                
                // æ£€æŸ¥ç½‘ç»œè¿é€šæ€§é—®é¢˜
                if (this.results.ping?.status === 'error') {
                    faultAnalysis += `ğŸ”´ ç½‘ç»œè¿é€šæ€§æ•…éšœ:\n`;
                    faultAnalysis += `   â†’ æœåŠ¡å™¨ç½‘ç»œä¸å¯è¾¾\n`;
                    faultAnalysis += `   â†’ å¯èƒ½åŸå› : ç½‘ç»œè·¯ç”±é—®é¢˜ã€æœåŠ¡å™¨ç¦»çº¿ã€DDoSæ”»å‡»\n`;
                    faultAnalysis += `   â†’ è§£å†³æ–¹æ¡ˆ: è”ç³»ISPã€æ£€æŸ¥æœåŠ¡å™¨çŠ¶æ€ã€å¯ç”¨DDoSé˜²æŠ¤\n\n`;
                }
                
                if (!faultAnalysis) {
                    faultAnalysis = `âœ… æ•…éšœåˆ†æ:\n`;
                    faultAnalysis += `   â†’ æœªå‘ç°æ˜æ˜¾æ•…éšœ\n`;
                    faultAnalysis += `   â†’ åŸŸååŸºæœ¬çŠ¶æ€æ­£å¸¸\n`;
                    faultAnalysis += `   â†’ å»ºè®®å®šæœŸè¿›è¡Œç»´æŠ¤æ£€æŸ¥\n`;
                }
                
                this.faultAnalysis = faultAnalysis;
            }
            
            // æ˜¾ç¤ºç»“æœ
            displayResults() {
                const container = document.getElementById('resultsContainer');
                
                // ç”Ÿæˆæ‘˜è¦
                const totalTests = Object.keys(this.results).length;
                const successTests = Object.values(this.results).filter(r => r.status === 'success').length;
                const errorTests = Object.values(this.results).filter(r => r.status === 'error').length;
                const warningTests = Object.values(this.results).filter(r => r.status === 'warning').length;
                
                let summaryHtml = `
                    <div class="summary">
                        <h3>ğŸ“Š è¯Šæ–­æŠ¥å‘Šæ‘˜è¦</h3>
                        <p><strong>è¯Šæ–­åŸŸå:</strong> ${this.domain}</p>
                        <p><strong>è¯Šæ–­æ—¶é—´:</strong> ${new Date().toLocaleString()}</p>
                        <p><strong>æ£€æµ‹é¡¹ç›®:</strong> ${totalTests}é¡¹</p>
                        <p><strong>é€šè¿‡:</strong> ${successTests}é¡¹ | <strong>è­¦å‘Š:</strong> ${warningTests}é¡¹ | <strong>é”™è¯¯:</strong> ${errorTests}é¡¹</p>
                `;
                
                if (errorTests === 0 && warningTests === 0) {
                    summaryHtml += `<p>ğŸ‰ åŸŸåçŠ¶æ€ä¼˜ç§€ï¼Œæ‰€æœ‰æ£€æµ‹é¡¹ç›®æ­£å¸¸</p>`;
                } else if (errorTests > 0) {
                    summaryHtml += `<p>ğŸ”´ å‘ç°${errorTests}ä¸ªä¸¥é‡é—®é¢˜ï¼Œéœ€è¦ç«‹å³å¤„ç†</p>`;
                } else if (warningTests > 0) {
                    summaryHtml += `<p>ğŸŸ¡ å‘ç°${warningTests}ä¸ªè­¦å‘Šé¡¹ç›®ï¼Œå»ºè®®ä¼˜åŒ–</p>`;
                }
                
                summaryHtml += `</div>`;
                
                // æ•…éšœåˆ†æ
                let faultHtml = '';
                if (this.faultAnalysis) {
                    const faultStatus = this.errors.length > 0 ? 'error' : 'success';
                    faultHtml = `
                        <div class="test-item ${faultStatus}">
                            <div class="test-header">
                                <div class="test-title">ğŸ” æ•…éšœåŸå› æ·±åº¦åˆ†æ</div>
                                <div class="test-status status-${faultStatus}">
                                    ${this.errors.length > 0 ? 'å‘ç°æ•…éšœ' : 'è¿è¡Œæ­£å¸¸'}
                                </div>
                            </div>
                            <div class="test-details">${this.faultAnalysis}</div>
                        </div>
                    `;
                }
                
                // é”™è¯¯åˆ—è¡¨
                let errorsHtml = '';
                if (this.errors.length > 0) {
                    errorsHtml = `
                        <div class="error-list">
                            <h3>âŒ å‘ç°çš„é—®é¢˜ (${this.errors.length}ä¸ª)</h3>
                            ${this.errors.map(error => `<div class="error-item">â€¢ ${error}</div>`).join('')}
                        </div>
                    `;
                }
                
                // å»ºè®®åˆ—è¡¨
                let recommendationsHtml = '';
                if (this.recommendations.length > 0) {
                    recommendationsHtml = `
                        <div class="recommendations">
                            <h3>ğŸ’¡ ä¼˜åŒ–å»ºè®® (${this.recommendations.length}æ¡)</h3>
                            ${this.recommendations.map(rec => `<div>â€¢ ${rec}</div>`).join('')}
                        </div>
                    `;
                }
                
                // è¯¦ç»†ç»“æœ
                let detailsHtml = '';
                const testOrder = ['dns', 'dnsFull', 'http', 'ssl', 'ports', 'whois', 'ping'];
                const testNames = {
                    dns: 'ğŸŒ åŸºç¡€DNSè§£æ',
                    dnsFull: 'ğŸ” å®Œæ•´DNSè§£æ',
                    http: 'ğŸ”— HTTP/HTTPSæ£€æµ‹',
                    ssl: 'ğŸ”’ SSLè¯ä¹¦æ£€æµ‹',
                    ports: 'ğŸšª ç«¯å£æ£€æµ‹',
                    whois: 'ğŸ“‹ WHOISä¿¡æ¯',
                    ping: 'ğŸ“¡ ç½‘ç»œè¿é€šæ€§'
                };
                
                testOrder.forEach(key => {
                    const result = this.results[key];
                    if (result) {
                        const statusClass = result.status;
                        const statusText = result.status === 'success' ? 'é€šè¿‡' : 
                                        result.status === 'error' ? 'å¤±è´¥' : 'è­¦å‘Š';
                        
                        detailsHtml += `
                            <div class="test-item ${statusClass}">
                                <div class="test-header">
                                    <div class="test-title">${testNames[key]}</div>
                                    <div class="test-status status-${statusClass}">${statusText}</div>
                                </div>
                                <div class="test-details">${result.details}</div>
                            </div>
                        `;
                    }
                });
                
                container.innerHTML = summaryHtml + faultHtml + errorsHtml + recommendationsHtml + detailsHtml;
            }
        }
        
        // å…¨å±€è¯Šæ–­å™¨å®ä¾‹
        const diagnostic = new ProfessionalDomainDiagnostic();
        
        // å¼€å§‹è¯Šæ–­
        async function startDiagnosis() {
            const domainInput = document.getElementById('domainInput');
            const domain = domainInput.value.trim();
            
            if (!domain) {
                const errorMessage = document.getElementById('errorMessage');
                errorMessage.textContent = 'è¯·è¾“å…¥è¦è¯Šæ–­çš„åŸŸå';
                errorMessage.style.display = 'block';
                return;
            }
            
            // ç®€å•çš„åŸŸåæ ¼å¼éªŒè¯
            const domainRegex = /^([a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
            if (!domainRegex.test(domain)) {
                const errorMessage = document.getElementById('errorMessage');
                errorMessage.textContent = 'è¯·è¾“å…¥æœ‰æ•ˆçš„åŸŸåæ ¼å¼ï¼ˆå¦‚ï¼šexample.comï¼‰';
                errorMessage.style.display = 'block';
                return;
            }
            
            document.getElementById('errorMessage').style.display = 'none';
            
            // ç¦ç”¨æŒ‰é’®é˜²æ­¢é‡å¤ç‚¹å‡»
            const diagnoseBtn = document.getElementById('diagnoseBtn');
            const originalText = diagnoseBtn.textContent;
            diagnoseBtn.textContent = 'è¯Šæ–­ä¸­...';
            diagnoseBtn.disabled = true;
            
            try {
                await diagnostic.startDiagnosis(domain);
            } catch (error) {
                console.error('è¯Šæ–­è¿‡ç¨‹å‡ºé”™:', error);
                document.getElementById('errorMessage').textContent = `è¯Šæ–­å‡ºé”™: ${error.message}`;
                document.getElementById('errorMessage').style.display = 'block';
            } finally {
                // æ¢å¤æŒ‰é’®çŠ¶æ€
                diagnoseBtn.textContent = originalText;
                diagnoseBtn.disabled = false;
            }
        }
        
        // æ”¯æŒå›è½¦é”®
        document.getElementById('domainInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') startDiagnosis();
        });
        
        // é¡µé¢åŠ è½½æ—¶å¯é€‰é»˜è®¤æ£€æµ‹
        window.addEventListener('DOMContentLoaded', () => {
            // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ ä¸€äº›åˆå§‹åŒ–ä»£ç 
            console.log('ä¸“ä¸šåŸŸåæ•…éšœè¯Šæ–­ç³»ç»Ÿå·²åŠ è½½');
        });
    </script>
</body>
</html>

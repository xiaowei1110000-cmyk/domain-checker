<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸŒ ä¸“ä¸šåŸŸåæ•…éšœè¯Šæ–­ç³»ç»Ÿ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #4f46e5 0%, #7e22ce 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .header p {
            opacity: 0.9;
            font-size: 1.1em;
        }
        
        .input-section {
            padding: 40px;
            background: #f8fafc;
        }
        
        .input-group {
            display: flex;
            gap: 10px;
            max-width: 600px;
            margin: 0 auto 20px;
        }
        
        input {
            flex: 1;
            padding: 15px 20px;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            font-size: 16px;
        }
        
        input:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }
        
        button {
            background: linear-gradient(135deg, #4f46e5 0%, #7e22ce 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(79, 70, 229, 0.3);
        }
        
        .test-selection {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 10px;
            max-width: 600px;
            margin: 0 auto;
        }
        
        .test-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px;
            background: white;
            border-radius: 8px;
            cursor: pointer;
        }
        
        .test-checkbox input {
            width: auto;
        }
        
        .results {
            padding: 0 40px 40px;
        }
        
        .test-item {
            background: white;
            border-radius: 10px;
            padding: 25px;
            margin-bottom: 20px;
            border: 1px solid #e2e8f0;
            border-left: 5px solid #e2e8f0;
            transition: all 0.3s;
        }
        
        .test-item.success {
            border-left-color: #10b981;
            background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
        }
        
        .test-item.error {
            border-left-color: #ef4444;
            background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%);
        }
        
        .test-item.warning {
            border-left-color: #f59e0b;
            background: linear-gradient(135deg, #fffbeb 0%, #fef3c7 100%);
        }
        
        .test-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .test-title {
            font-size: 18px;
            font-weight: 600;
            color: #1e293b;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .test-status {
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
        }
        
        .status-success {
            background: #d1fae5;
            color: #065f46;
        }
        
        .status-error {
            background: #fee2e2;
            color: #991b1b;
        }
        
        .status-warning {
            background: #fef3c7;
            color: #92400e;
        }
        
        .test-details {
            color: #475569;
            line-height: 1.6;
            font-family: 'Consolas', 'Monaco', monospace;
            background: rgba(255,255,255,0.7);
            padding: 20px;
            border-radius: 8px;
            margin-top: 15px;
            font-size: 14px;
            white-space: pre-wrap;
            word-break: break-all;
        }
        
        .summary {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 30px;
        }
        
        .summary h3 {
            font-size: 20px;
            margin-bottom: 15px;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #64748b;
            display: none;
        }
        
        .loading-spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #4f46e5;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .error-list {
            background: #fef2f2;
            border: 2px solid #ef4444;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .error-item {
            padding: 10px;
            margin: 5px 0;
            background: white;
            border-radius: 5px;
            border-left: 4px solid #ef4444;
        }
        
        .recommendations {
            background: #dbeafe;
            border: 2px solid #3b82f6;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }
        
        /* æ•…éšœè·Ÿè¸ªæ­¥éª¤æ ·å¼ */
        .step-tracking {
            background: #f8fafc;
            border: 2px solid #94a3b8;
            border-radius: 10px;
            padding: 25px;
            margin: 20px 0;
        }
        
        .step-tracking h3 {
            color: #334155;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .step-list {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .step {
            display: flex;
            align-items: center;
            padding: 12px 15px;
            background: white;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            transition: all 0.3s;
        }
        
        .step.completed {
            border-left: 4px solid #10b981;
            background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
        }
        
        .step.failed {
            border-left: 4px solid #ef4444;
            background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%);
        }
        
        .step.current {
            border-left: 4px solid #3b82f6;
            background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
            animation: pulse 2s infinite;
        }
        
        .step-number {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: #e2e8f0;
            color: #475569;
            font-weight: bold;
            margin-right: 15px;
        }
        
        .step.completed .step-number {
            background: #10b981;
            color: white;
        }
        
        .step.failed .step-number {
            background: #ef4444;
            color: white;
        }
        
        .step.current .step-number {
            background: #3b82f6;
            color: white;
        }
        
        .step-content {
            flex: 1;
        }
        
        .step-title {
            font-weight: 600;
            margin-bottom: 5px;
        }
        
        .step-description {
            font-size: 14px;
            color: #64748b;
        }
        
        .step-time {
            font-size: 12px;
            color: #94a3b8;
            margin-top: 3px;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(59, 130, 246, 0); }
            100% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0); }
        }
        
        .resolution-steps {
            background: #f0fdf4;
            border: 2px solid #10b981;
            border-radius: 10px;
            padding: 25px;
            margin: 20px 0;
        }
        
        .resolution-steps h3 {
            color: #065f46;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .resolution-item {
            padding: 10px 15px;
            margin: 8px 0;
            background: white;
            border-radius: 6px;
            border-left: 4px solid #10b981;
        }
        
        @media (max-width: 768px) {
            .container {
                border-radius: 10px;
            }
            
            .header, .input-section, .results {
                padding: 20px;
            }
            
            .input-group {
                flex-direction: column;
            }
            
            button {
                width: 100%;
            }
            
            .step {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }
            
            .step-number {
                margin-right: 0;
                margin-bottom: 5px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ” ä¸“ä¸šåŸŸåæ•…éšœè¯Šæ–­ç³»ç»Ÿ</h1>
            <p>ç²¾ç¡®æ£€æµ‹åŸŸåæ— æ³•è®¿é—®çš„å…·ä½“åŸå›  | WHOISæŸ¥è¯¢ | DNSæ£€æµ‹ | SSLåˆ†æ</p>
        </div>
        
        <div class="input-section">
            <div class="input-group">
                <input type="text" id="domainInput" 
                       placeholder="è¾“å…¥è¦è¯Šæ–­çš„åŸŸåï¼ˆä¾‹å¦‚ï¼šexample.comï¼‰" 
                       value="baidu.com">
                <button id="diagnoseBtn" onclick="startDiagnosis()">å¼€å§‹å…¨é¢è¯Šæ–­</button>
            </div>
            
            <div class="test-selection">
                <label class="test-checkbox">
                    <input type="checkbox" id="checkDNS" checked> ğŸŒ DNSè§£ææ£€æµ‹
                </label>
                <label class="test-checkbox">
                    <input type="checkbox" id="checkHTTP" checked> ğŸ”— HTTP/HTTPSæ£€æµ‹
                </label>
                <label class="test-checkbox">
                    <input type="checkbox" id="checkSSL" checked> ğŸ”’ SSLè¯ä¹¦æ£€æµ‹
                </label>
                <label class="test-checkbox">
                    <input type="checkbox" id="checkWHOIS" checked> ğŸ“‹ WHOISä¿¡æ¯
                </label>
                <label class="test-checkbox">
                    <input type="checkbox" id="checkPing" checked> ğŸ“¡ Pingæµ‹è¯•
                </label>
            </div>
            
            <div id="errorMessage" style="display:none;color:#ef4444;text-align:center;margin-top:10px;"></div>
        </div>
        
        <div class="results" id="resultsContainer">
            <div class="loading" id="loading">
                <div class="loading-spinner"></div>
                <p>æ­£åœ¨æ‰§è¡Œæ·±åº¦è¯Šæ–­ï¼Œè¯·ç¨å€™...</p>
            </div>
            <!-- ç»“æœå°†åŠ¨æ€ç”Ÿæˆ -->
        </div>
    </div>

    <script>
        class ProfessionalDomainDiagnostic {
            constructor() {
                this.domain = '';
                this.results = {};
                this.errors = [];
                this.recommendations = [];
                this.steps = [];
                this.failurePoint = null;
            }
            
            async startDiagnosis(domain) {
                this.domain = domain;
                this.results = {};
                this.errors = [];
                this.recommendations = [];
                this.steps = [];
                this.failurePoint = null;
                
                document.getElementById('loading').style.display = 'block';
                document.getElementById('resultsContainer').innerHTML = '';
                
                try {
                    const startTime = Date.now();
                    
                    // æŒ‰é¡ºåºæ‰§è¡Œè¯Šæ–­æ­¥éª¤
                    await this.performStepByStepDiagnosis();
                    
                    // åˆ†ææ•…éšœåŸå› 
                    this.analyzeFaults();
                    
                    // æ˜¾ç¤ºç»“æœ
                    this.displayResults();
                    
                } catch (error) {
                    document.getElementById('errorMessage').textContent = `è¯Šæ–­å¤±è´¥: ${error.message}`;
                    document.getElementById('errorMessage').style.display = 'block';
                } finally {
                    document.getElementById('loading').style.display = 'none';
                }
            }
            
            async performStepByStepDiagnosis() {
                // æ­¥éª¤1: æ£€æŸ¥åŸŸåæ ¼å¼
                await this.addStep('æ£€æŸ¥åŸŸåæ ¼å¼', 'éªŒè¯åŸŸåæ ¼å¼æ˜¯å¦æ­£ç¡®');
                const domainRegex = /^(?!:\/\/)([a-zA-Z0-9-]+\.)+[a-zA-Z]{2,}$/;
                if (!domainRegex.test(this.domain)) {
                    this.markStepFailed('åŸŸåæ ¼å¼ä¸æ­£ç¡®');
                    throw new Error('åŸŸåæ ¼å¼ä¸æ­£ç¡®');
                }
                this.markStepCompleted();
                
                // æ­¥éª¤2: DNSè§£ææ£€æµ‹
                await this.addStep('DNSè§£ææ£€æµ‹', 'å°†åŸŸåè½¬æ¢ä¸ºIPåœ°å€');
                const dnsResult = await this.checkDNS();
                this.results.dns = dnsResult.dns;
                if (dnsResult.dns.status === 'error') {
                    this.markStepFailed('DNSè§£æå¤±è´¥');
                    this.failurePoint = 'DNSè§£æé˜¶æ®µ';
                    return;
                }
                this.markStepCompleted();
                
                // æ­¥éª¤3: ç½‘ç»œè¿é€šæ€§æ£€æµ‹
                await this.addStep('ç½‘ç»œè¿é€šæ€§æ£€æµ‹', 'æµ‹è¯•æœåŠ¡å™¨æ˜¯å¦å¯è¾¾');
                const pingResult = await this.checkPing();
                this.results.ping = pingResult.ping;
                if (pingResult.ping.status === 'error') {
                    this.markStepFailed('æœåŠ¡å™¨ä¸å¯è¾¾');
                    this.failurePoint = 'ç½‘ç»œè¿æ¥é˜¶æ®µ';
                    return;
                }
                this.markStepCompleted();
                
                // æ­¥éª¤4: HTTP/HTTPSæ£€æµ‹
                await this.addStep('HTTPæœåŠ¡æ£€æµ‹', 'æ£€æŸ¥WebæœåŠ¡æ˜¯å¦è¿è¡Œ');
                const httpResult = await this.checkHTTP();
                this.results.http = httpResult.http;
                if (httpResult.http.status === 'error') {
                    this.markStepFailed('HTTPæœåŠ¡ä¸å¯ç”¨');
                    this.failurePoint = 'HTTPæœåŠ¡é˜¶æ®µ';
                    return;
                }
                this.markStepCompleted();
                
                // æ­¥éª¤5: SSLè¯ä¹¦æ£€æµ‹
                await this.addStep('SSLè¯ä¹¦æ£€æµ‹', 'éªŒè¯HTTPSè¯ä¹¦æœ‰æ•ˆæ€§');
                const sslResult = await this.checkSSL();
                this.results.ssl = sslResult.ssl;
                if (sslResult.ssl.status === 'error') {
                    this.markStepFailed('SSLè¯ä¹¦æœ‰é—®é¢˜');
                    this.failurePoint = 'SSLè¯ä¹¦é˜¶æ®µ';
                }
                this.markStepCompleted();
                
                // æ­¥éª¤6: WHOISä¿¡æ¯æŸ¥è¯¢
                await this.addStep('WHOISä¿¡æ¯æŸ¥è¯¢', 'è·å–åŸŸåæ³¨å†Œä¿¡æ¯');
                const whoisResult = await this.checkWHOIS();
                this.results.whois = whoisResult.whois;
                this.markStepCompleted();
                
                // æ‰€æœ‰æ­¥éª¤å®Œæˆ
                await this.addStep('è¯Šæ–­å®Œæˆ', 'æ‰€æœ‰æ£€æµ‹é¡¹ç›®å®Œæˆ');
                this.markStepCompleted();
            }
            
            async addStep(title, description) {
                const step = {
                    id: this.steps.length + 1,
                    title,
                    description,
                    status: 'pending',
                    startTime: Date.now(),
                    endTime: null,
                    error: null
                };
                this.steps.push(step);
                
                await new Promise(resolve => setTimeout(resolve, 300));
            }
            
            markStepCompleted() {
                if (this.steps.length > 0) {
                    const currentStep = this.steps[this.steps.length - 1];
                    currentStep.status = 'completed';
                    currentStep.endTime = Date.now();
                }
            }
            
            markStepFailed(errorMessage) {
                if (this.steps.length > 0) {
                    const currentStep = this.steps[this.steps.length - 1];
                    currentStep.status = 'failed';
                    currentStep.endTime = Date.now();
                    currentStep.error = errorMessage;
                }
            }
            
            // 1. DNSæ·±åº¦æ£€æµ‹ - ä¿®å¤ç‰ˆæœ¬
            async checkDNS() {
                try {
                    const startTime = Date.now();
                    let details = `ğŸŒ DNSè§£ææ£€æµ‹:\n\n`;
                    
                    // æ–¹æ³•1: ä½¿ç”¨Cloudflare DNS API
                    try {
                        const response = await fetch(
                            `https://cloudflare-dns.com/dns-query?name=${this.domain}&type=A`,
                            { 
                                headers: { 
                                    'Accept': 'application/dns-json'
                                },
                                mode: 'cors'
                            }
                        );
                        
                        const data = await response.json();
                        const time = Date.now() - startTime;
                        
                        details += `â±ï¸ å“åº”æ—¶é—´: ${time}ms\n`;
                        
                        if (data.Status === 0 && data.Answer && data.Answer.length > 0) {
                            const ips = data.Answer.map(a => a.data).join(', ');
                            details += `âœ… DNSè§£ææˆåŠŸ\n`;
                            details += `ğŸ“Œ è§£æåˆ°IPåœ°å€: ${ips}\n`;
                            details += `ğŸ“Š TTL: ${data.Answer[0].TTL}ç§’\n`;
                            
                            if (data.Answer.length > 1) {
                                details += `ğŸ”€ æ£€æµ‹åˆ°${data.Answer.length}ä¸ªIPï¼Œå¯èƒ½ä½¿ç”¨è´Ÿè½½å‡è¡¡\n`;
                            }
                            
                            // é¢å¤–æ£€æŸ¥ï¼šæ£€æŸ¥IPv6
                            try {
                                const ipv6Response = await fetch(
                                    `https://cloudflare-dns.com/dns-query?name=${this.domain}&type=AAAA`,
                                    { 
                                        headers: { 
                                            'Accept': 'application/dns-json'
                                        },
                                        mode: 'cors'
                                    }
                                );
                                
                                const ipv6Data = await ipv6Response.json();
                                if (ipv6Data.Status === 0 && ipv6Data.Answer && ipv6Data.Answer.length > 0) {
                                    const ipv6Ips = ipv6Data.Answer.map(a => a.data).join(', ');
                                    details += `ğŸŒ IPv6åœ°å€: ${ipv6Ips}\n`;
                                }
                            } catch (e) {
                                details += `â„¹ï¸ IPv6æ£€æµ‹å¤±è´¥\n`;
                            }
                            
                            this.ips = data.Answer.map(a => a.data);
                            
                            return { dns: { status: 'success', details, raw: data, time } };
                            
                        } else {
                            details += `âŒ DNSè§£æå¤±è´¥\n`;
                            details += `ğŸ“Š é”™è¯¯ä»£ç : ${data.Status || 'æœªçŸ¥'}\n`;
                            this.errors.push('DNSè§£æå¤±è´¥ - åŸŸåæ— æ³•è§£æåˆ°IPåœ°å€');
                            return { dns: { status: 'error', details, time } };
                        }
                        
                    } catch (cloudflareError) {
                        details += `â„¹ï¸ Cloudflare DNSæŸ¥è¯¢å¤±è´¥ï¼Œå°è¯•å¤‡ç”¨æ–¹æ³•...\n`;
                    }
                    
                    // æ–¹æ³•2: ä½¿ç”¨Google DNS API
                    try {
                        const response = await fetch(
                            `https://dns.google/resolve?name=${this.domain}&type=A`,
                            { 
                                headers: { 
                                    'Accept': 'application/dns-json'
                                },
                                mode: 'cors'
                            }
                        );
                        
                        const data = await response.json();
                        const time = Date.now() - startTime;
                        
                        if (data.Status === 0 && data.Answer && data.Answer.length > 0) {
                            const ips = data.Answer.map(a => a.data).join(', ');
                            details += `âœ… DNSè§£ææˆåŠŸ (Google DNS)\n`;
                            details += `ğŸ“Œ è§£æåˆ°IPåœ°å€: ${ips}\n`;
                            
                            this.ips = data.Answer.map(a => a.data);
                            return { dns: { status: 'success', details, raw: data, time } };
                        }
                    } catch (googleError) {
                        details += `â„¹ï¸ Google DNSæŸ¥è¯¢å¤±è´¥\n`;
                    }
                    
                    // æ–¹æ³•3: ä½¿ç”¨ç®€å•çš„HTTPæ–¹æ³•æ£€æµ‹
                    try {
                        // å°è¯•ç›´æ¥è®¿é—®åŸŸåæ¥éªŒè¯DNSè§£æ
                        const testStart = Date.now();
                        await fetch(`https://${this.domain}`, {
                            method: 'HEAD',
                            mode: 'no-cors',
                            signal: AbortSignal.timeout(5000)
                        });
                        const testTime = Date.now() - testStart;
                        
                        details += `âœ… åŸŸåå¯ä»¥è®¿é—®ï¼ŒDNSè§£ææ­£å¸¸ (${testTime}ms)\n`;
                        details += `â„¹ï¸ ç›´æ¥é€šè¿‡HTTPSè®¿é—®éªŒè¯DNSè§£æ\n`;
                        
                        return { dns: { status: 'success', details, time: Date.now() - startTime } };
                        
                    } catch (httpError) {
                        details += `âŒ æ‰€æœ‰DNSæ£€æµ‹æ–¹æ³•éƒ½å¤±è´¥\n`;
                        details += `ğŸ” å¯èƒ½åŸå› :\n`;
                        details += `1. åŸŸåæœªæ³¨å†Œæˆ–å·²è¿‡æœŸ\n`;
                        details += `2. DNSæœåŠ¡å™¨é…ç½®é”™è¯¯\n`;
                        details += `3. ç½‘ç»œè¿æ¥é—®é¢˜\n`;
                        details += `4. åŸŸåæ‹¼å†™é”™è¯¯\n`;
                        
                        this.errors.push('DNSè§£æå¤±è´¥ - åŸŸåæ— æ³•è§£æåˆ°IPåœ°å€');
                        return { dns: { status: 'error', details, time: Date.now() - startTime } };
                    }
                    
                } catch (error) {
                    return { dns: { 
                        status: 'error', 
                        details: `âŒ DNSæ£€æµ‹å¤±è´¥\nğŸ“Š é”™è¯¯: ${error.message}\n\nğŸ” å¯èƒ½åŸå› :\n1. ç½‘ç»œè¿æ¥é—®é¢˜\n2. DNSæŸ¥è¯¢æœåŠ¡ä¸å¯ç”¨`,
                        time: 0
                    } };
                }
            }
            
            // 2. HTTP/HTTPSæ£€æµ‹ - ä¿®å¤ç‰ˆæœ¬
            async checkHTTP() {
                const results = {};
                let details = '';
                let hasSuccess = false;
                let totalTime = 0;
                
                details += `ğŸ” HTTP/HTTPSæœåŠ¡æ£€æµ‹:\n\n`;
                
                // æ£€æµ‹HTTPS
                details += `ğŸ”’ HTTPSæ£€æµ‹:\n`;
                try {
                    const startTime = Date.now();
                    const controller = new AbortController();
                    setTimeout(() => controller.abort(), 10000);
                    
                    // ä½¿ç”¨ä»£ç†ç»•è¿‡CORSé™åˆ¶
                    const response = await fetch(`https://api.allorigins.win/get?url=${encodeURIComponent(`https://${this.domain}`)}&method=HEAD`, {
                        signal: controller.signal
                    });
                    
                    const time = Date.now() - startTime;
                    totalTime += time;
                    
                    if (response.ok) {
                        details += `   âœ… è¿æ¥æˆåŠŸ (${time}ms)\n`;
                        results.https = { success: true, time };
                        hasSuccess = true;
                    } else {
                        details += `   âŒ è¿æ¥å¤±è´¥ï¼ŒçŠ¶æ€ç : ${response.status}\n`;
                        results.https = { success: false, error: `HTTP ${response.status}` };
                    }
                    
                } catch (error) {
                    results.https = { success: false, error: error.message };
                    details += `   âŒ è¿æ¥å¤±è´¥: ${error.message}\n`;
                }
                
                // æ£€æµ‹HTTP
                details += `ğŸŒ HTTPæ£€æµ‹:\n`;
                try {
                    const startTime = Date.now();
                    const controller = new AbortController();
                    setTimeout(() => controller.abort(), 10000);
                    
                    // ä½¿ç”¨ä»£ç†ç»•è¿‡CORSé™åˆ¶
                    const response = await fetch(`https://api.allorigins.win/get?url=${encodeURIComponent(`http://${this.domain}`)}&method=HEAD`, {
                        signal: controller.signal
                    });
                    
                    const time = Date.now() - startTime;
                    totalTime += time;
                    
                    if (response.ok) {
                        details += `   âœ… è¿æ¥æˆåŠŸ (${time}ms)\n`;
                        results.http = { success: true, time };
                        hasSuccess = true;
                    } else {
                        details += `   âŒ è¿æ¥å¤±è´¥ï¼ŒçŠ¶æ€ç : ${response.status}\n`;
                        results.http = { success: false, error: `HTTP ${response.status}` };
                    }
                    
                } catch (error) {
                    results.http = { success: false, error: error.message };
                    details += `   âŒ è¿æ¥å¤±è´¥: ${error.message}\n`;
                }
                
                // åˆ†æç»“æœ
                const status = hasSuccess ? 'success' : 'error';
                
                if (!hasSuccess) {
                    details += `\nğŸ” æ•…éšœåˆ†æ:\n`;
                    details += `ğŸ“Œ é—®é¢˜: HTTP/HTTPSæœåŠ¡å‡ä¸å¯ç”¨\n\n`;
                    details += `ğŸ’¡ å¯èƒ½åŸå› :\n`;
                    details += `1. WebæœåŠ¡å™¨æœªè¿è¡Œæˆ–å®•æœº\n`;
                    details += `2. é˜²ç«å¢™é˜»æ­¢80/443ç«¯å£è®¿é—®\n`;
                    details += `3. æœåŠ¡å™¨é…ç½®é”™è¯¯\n`;
                    
                    this.errors.push('HTTP/HTTPSæœåŠ¡ä¸å¯ç”¨');
                } else if (!results.https.success && results.http.success) {
                    details += `\nâš ï¸ æ³¨æ„:\n`;
                    details += `ğŸ“Œ HTTPSæœªé…ç½®æˆ–è¯ä¹¦æœ‰é—®é¢˜ï¼Œä½†HTTPå¯è®¿é—®\n`;
                    this.recommendations.push('é…ç½®HTTPSå’ŒSSLè¯ä¹¦');
                }
                
                return { http: { status, details, results, time: totalTime } };
            }
            
            // 3. SSLè¯ä¹¦æ£€æµ‹ - ä¿®å¤è¯ä¹¦æœ‰æ•ˆæœŸé—®é¢˜
            async checkSSL() {
                try {
                    let details = '';
                    let status = 'success';
                    const startTime = Date.now();
                    
                    details += `ğŸ”’ SSLè¯ä¹¦æ£€æµ‹:\n\n`;
                    
                    try {
                        // æ–¹æ³•1: ä½¿ç”¨ä»£ç†è·å–è¯ä¹¦ä¿¡æ¯
                        const controller = new AbortController();
                        setTimeout(() => controller.abort(), 15000);
                        
                        // ä½¿ç”¨alloriginsä»£ç†è·å–SSLä¿¡æ¯
                        const response = await fetch(`https://api.allorigins.win/get?url=${encodeURIComponent(`https://${this.domain}`)}`, {
                            signal: controller.signal
                        });
                        
                        const time = Date.now() - startTime;
                        
                        if (response.ok) {
                            details += `âœ… HTTPSè¿æ¥æˆåŠŸ\n`;
                            details += `â±ï¸ è¿æ¥æ—¶é—´: ${time}ms\n`;
                            details += `ğŸ” å®‰å…¨è¿æ¥å·²å»ºç«‹\n`;
                            
                            // æ–¹æ³•2: ä½¿ç”¨SSLè¯ä¹¦æ£€æŸ¥API
                            try {
                                details += `\nğŸ” æ­£åœ¨è·å–SSLè¯ä¹¦è¯¦ç»†ä¿¡æ¯...\n`;
                                
                                // ä½¿ç”¨å…¬å…±çš„SSLè¯ä¹¦æ£€æŸ¥API
                                const certResponse = await fetch(`https://api.allorigins.win/get?url=${encodeURIComponent(`https://crt.sh/?q=${this.domain}&output=json`)}`, {
                                    signal: AbortSignal.timeout(8000)
                                });
                                
                                if (certResponse.ok) {
                                    const certData = await certResponse.json();
                                    const certificates = JSON.parse(certData.contents);
                                    
                                    if (certificates && certificates.length > 0) {
                                        const cert = certificates[0];
                                        
                                        // æ˜¾ç¤ºè¯ä¹¦ä¿¡æ¯
                                        if (cert.not_before) {
                                            details += `ğŸ“… è¯ä¹¦ç”Ÿæ•ˆæ—¶é—´: ${new Date(cert.not_before).toLocaleDateString()}\n`;
                                        }
                                        
                                        if (cert.not_after) {
                                            const expiryDate = new Date(cert.not_after);
                                            details += `ğŸ“… è¯ä¹¦è¿‡æœŸæ—¶é—´: ${expiryDate.toLocaleDateString()}\n`;
                                            
                                            // è®¡ç®—å‰©ä½™å¤©æ•°
                                            const now = new Date();
                                            const daysLeft = Math.ceil((expiryDate - now) / (1000 * 60 * 60 * 24));
                                            details += `ğŸ“† è¯ä¹¦å‰©ä½™å¤©æ•°: ${daysLeft}å¤©\n`;
                                            
                                            if (daysLeft < 30) {
                                                details += `âš ï¸ è­¦å‘Š: SSLè¯ä¹¦å°†åœ¨${daysLeft}å¤©åè¿‡æœŸï¼\n`;
                                                this.errors.push(`SSLè¯ä¹¦å°†åœ¨${daysLeft}å¤©åè¿‡æœŸ`);
                                                status = 'warning';
                                                this.recommendations.push('ç«‹å³æ›´æ–°SSLè¯ä¹¦');
                                            }
                                            
                                            if (expiryDate < now) {
                                                details += `ğŸš¨ ä¸¥é‡: SSLè¯ä¹¦å·²è¿‡æœŸï¼\n`;
                                                this.errors.push('SSLè¯ä¹¦å·²è¿‡æœŸ');
                                                status = 'error';
                                            }
                                        }
                                        
                                        if (cert.issuer_name) {
                                            details += `ğŸ¢ é¢å‘æœºæ„: ${cert.issuer_name}\n`;
                                        }
                                        
                                        if (cert.common_name) {
                                            details += `ğŸŒ è¯ä¹¦åŸŸå: ${cert.common_name}\n`;
                                        }
                                    }
                                }
                            } catch (certError) {
                                details += `â„¹ï¸ è¯¦ç»†è¯ä¹¦ä¿¡æ¯è·å–å¤±è´¥\n`;
                                details += `ğŸ’¡ å»ºè®®ä½¿ç”¨åœ¨çº¿å·¥å…·æ£€æŸ¥:\n`;
                                details += `â€¢ https://www.ssllabs.com/ssltest/analyze.html?d=${this.domain}\n`;
                                details += `â€¢ https://crt.sh/?q=${this.domain}\n`;
                            }
                            
                        } else {
                            status = 'error';
                            details += `âŒ HTTPSè¿æ¥å¤±è´¥\n`;
                            details += `â±ï¸ å°è¯•æ—¶é—´: ${time}ms\n`;
                            details += `ğŸ” å¯èƒ½åŸå› :\n`;
                            details += `1. ç½‘ç«™æœªå¯ç”¨HTTPS\n`;
                            details += `2. SSLè¯ä¹¦é…ç½®é”™è¯¯\n`;
                            
                            this.errors.push('HTTPSè¿æ¥å¤±è´¥');
                            this.recommendations.push('æ£€æŸ¥SSLè¯ä¹¦é…ç½®');
                        }
                        
                    } catch (error) {
                        status = 'error';
                        const time = Date.now() - startTime;
                        details += `âŒ SSL/TLSæ£€æµ‹å¤±è´¥\n`;
                        details += `â±ï¸ å°è¯•æ—¶é—´: ${time}ms\n`;
                        details += `ğŸ“Š é”™è¯¯: ${error.message}\n\n`;
                        details += `ğŸ” å¯èƒ½åŸå› :\n`;
                        details += `1. ç½‘ç«™æœªå¯ç”¨HTTPS\n`;
                        details += `2. SSLè¯ä¹¦é…ç½®é”™è¯¯\n`;
                        details += `3. è¯ä¹¦ä¸å—ä¿¡ä»»\n`;
                        
                        this.errors.push('SSL/TLSæ£€æµ‹å¤±è´¥');
                        this.recommendations.push('æ£€æŸ¥SSLè¯ä¹¦é…ç½®');
                    }
                    
                    return { ssl: { status, details, time: Date.now() - startTime } };
                    
                } catch (error) {
                    return { ssl: { 
                        status: 'error', 
                        details: `âŒ SSLæ£€æµ‹å¼‚å¸¸\né”™è¯¯: ${error.message}`,
                        time: 0
                    } };
                }
            }
            
            // 4. WHOISä¿¡æ¯æŸ¥è¯¢
            async checkWHOIS() {
                try {
                    const startTime = Date.now();
                    let details = `ğŸ“‹ WHOISåŸŸåæ³¨å†Œä¿¡æ¯æŸ¥è¯¢:\n\n`;
                    let status = 'success';
                    
                    try {
                        // ä½¿ç”¨ä»£ç†æŸ¥è¯¢WHOISä¿¡æ¯
                        const response = await fetch(`https://api.allorigins.win/get?url=${encodeURIComponent(`https://whois.icann.org/en/lookup?name=${this.domain}`)}`, {
                            method: 'GET',
                            signal: AbortSignal.timeout(10000)
                        });
                        
                        const data = await response.json();
                        const queryTime = Date.now() - startTime;
                        
                        details += `â±ï¸ æŸ¥è¯¢æ—¶é—´: ${queryTime}ms\n`;
                        
                        if (data.contents) {
                            const content = data.contents;
                            
                            // æå–å…³é”®ä¿¡æ¯
                            if (content.includes('Domain Name:')) {
                                details += `âœ… WHOISä¿¡æ¯è·å–æˆåŠŸ\n\n`;
                                
                                // æå–åŸŸå
                                const domainMatch = content.match(/Domain Name:\s*([^\n]+)/i);
                                if (domainMatch) details += `ğŸŒ åŸŸå: ${domainMatch[1].trim()}\n`;
                                
                                // æå–æ³¨å†Œå•†
                                const registrarMatch = content.match(/Registrar:\s*([^\n]+)/i);
                                if (registrarMatch) details += `ğŸ¢ æ³¨å†Œå•†: ${registrarMatch[1].trim()}\n`;
                                
                                // æå–åˆ›å»ºæ—¶é—´
                                const createdMatch = content.match(/Creation Date:\s*([^\n]+)/i);
                                if (createdMatch) details += `ğŸ“… åˆ›å»ºæ—¶é—´: ${createdMatch[1].trim()}\n`;
                                
                                // æå–è¿‡æœŸæ—¶é—´
                                const expiresMatch = content.match(/Registry Expiry Date:\s*([^\n]+)/i);
                                if (expiresMatch) {
                                    const expiryDate = expiresMatch[1].trim();
                                    details += `â° è¿‡æœŸæ—¶é—´: ${expiryDate}\n`;
                                    
                                    // è®¡ç®—å‰©ä½™å¤©æ•°
                                    try {
                                        const dateMatch = expiryDate.match(/(\d{4}-\d{2}-\d{2})/);
                                        if (dateMatch) {
                                            const expDate = new Date(dateMatch[1]);
                                            const now = new Date();
                                            const daysLeft = Math.ceil((expDate - now) / (1000 * 60 * 60 * 24));
                                            
                                            details += `ğŸ“† å‰©ä½™å¤©æ•°: ${daysLeft}å¤©\n`;
                                            
                                            if (daysLeft < 30) {
                                                details += `âš ï¸ è­¦å‘Š: åŸŸåå°†åœ¨${daysLeft}å¤©åè¿‡æœŸï¼\n`;
                                                this.errors.push(`åŸŸåå³å°†åœ¨${daysLeft}å¤©åè¿‡æœŸ`);
                                                this.recommendations.push('ç«‹å³ç»­è´¹åŸŸå');
                                            }
                                        }
                                    } catch (e) {}
                                }
                                
                                // æå–DNSæœåŠ¡å™¨
                                const dnsMatches = content.match(/Name Server:\s*([^\n]+)/gi);
                                if (dnsMatches && dnsMatches.length > 0) {
                                    details += `ğŸŒ DNSæœåŠ¡å™¨:\n`;
                                    dnsMatches.slice(0, 3).forEach((ns, index) => {
                                        const nsName = ns.replace(/Name Server:\s*/i, '').trim();
                                        details += `   ${index + 1}. ${nsName}\n`;
                                    });
                                }
                                
                                // æå–çŠ¶æ€
                                const statusMatches = content.match(/Domain Status:\s*([^\n]+)/gi);
                                if (statusMatches && statusMatches.length > 0) {
                                    const statuses = statusMatches.map(s => s.replace(/Domain Status:\s*/i, '').trim());
                                    details += `ğŸ“Š çŠ¶æ€: ${statuses.join(', ')}\n`;
                                }
                            } else {
                                status = 'warning';
                                details += `âš ï¸ WHOISä¿¡æ¯æ ¼å¼è§£æå¤±è´¥\n`;
                            }
                        } else {
                            status = 'warning';
                            details += `âš ï¸ WHOISä¿¡æ¯è·å–å—é™\n`;
                        }
                        
                    } catch (apiError) {
                        status = 'warning';
                        details += `âš ï¸ WHOISæŸ¥è¯¢å¤±è´¥\n`;
                        details += `é”™è¯¯: ${apiError.message}\n\n`;
                    }
                    
                    details += `\nğŸ’¡ æ›¿ä»£æŸ¥è¯¢æ–¹æ³•:\n`;
                    details += `â€¢ https://whois.icann.org/zh/lookup?name=${this.domain}\n`;
                    details += `â€¢ https://www.whois.com/whois/${this.domain}\n`;
                    
                    return { whois: { status, details, queryTime: Date.now() - startTime } };
                    
                } catch (error) {
                    return { whois: { 
                        status: 'warning', 
                        details: `âš ï¸ WHOISæŸ¥è¯¢å¼‚å¸¸\né”™è¯¯: ${error.message}\n\nğŸ’¡ å»ºè®®ç›´æ¥è®¿é—®:\nâ€¢ https://whois.icann.org/zh/lookup?name=${this.domain}`
                    } };
                }
            }
            
            // 5. Pingæµ‹è¯•ï¼ˆç½‘ç»œè¿é€šæ€§ï¼‰
            async checkPing() {
                try {
                    const startTime = performance.now();
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 8000);
                    
                    // ä½¿ç”¨ä»£ç†è¿›è¡Œè¿æ¥æµ‹è¯•
                    const response = await fetch(`https://api.allorigins.win/get?url=${encodeURIComponent(`https://${this.domain}`)}&method=HEAD`, {
                        signal: controller.signal
                    });
                    
                    clearTimeout(timeoutId);
                    const time = Math.round(performance.now() - startTime);
                    
                    let details = `ğŸ“¡ ç½‘ç»œè¿é€šæ€§æµ‹è¯•:\n\n`;
                    details += `âœ… æœåŠ¡å™¨å¯è¾¾\n`;
                    details += `â±ï¸ å“åº”æ—¶é—´: ${time}ms\n`;
                    
                    let quality = 'ä¼˜ç§€';
                    if (time > 100) quality = 'è‰¯å¥½';
                    if (time > 300) quality = 'ä¸€èˆ¬';
                    if (time > 1000) quality = 'è¾ƒå·®';
                    if (time > 3000) quality = 'å¾ˆå·®';
                    
                    details += `ğŸ“Š ç½‘ç»œè´¨é‡: ${quality}\n`;
                    
                    if (time > 500) {
                        details += `âš ï¸ å“åº”æ—¶é—´è¾ƒé•¿\n`;
                        details += `ğŸ’¡ å»ºè®®: ä¼˜åŒ–æœåŠ¡å™¨æ€§èƒ½æˆ–ä½¿ç”¨CDN\n`;
                        this.recommendations.push('ä¼˜åŒ–æœåŠ¡å™¨å“åº”æ—¶é—´');
                    }
                    
                    return { ping: { status: 'success', details, time } };
                    
                } catch (error) {
                    // å°è¯•HTTP
                    try {
                        const startTime = performance.now();
                        await fetch(`https://api.allorigins.win/get?url=${encodeURIComponent(`http://${this.domain}`)}&method=HEAD`, {
                            signal: AbortSignal.timeout(8000)
                        });
                        const time = Math.round(performance.now() - startTime);
                        
                        let details = `ğŸ“¡ ç½‘ç»œè¿é€šæ€§æµ‹è¯•:\n\n`;
                        details += `âš ï¸ HTTPSä¸å¯è¾¾ï¼Œä½†HTTPå¯è¾¾ (${time}ms)\n`;
                        details += `ğŸ”’ å»ºè®®å¯ç”¨HTTPSåŠ å¯†è¿æ¥\n`;
                        
                        return { ping: { status: 'warning', details, time } };
                        
                    } catch (httpError) {
                        let details = `âŒ ç½‘ç»œè¿é€šæ€§æµ‹è¯•å¤±è´¥\n`;
                        details += `ğŸ“Š é”™è¯¯ç±»å‹: ${error.name}\n\n`;
                        details += `ğŸ” å¯èƒ½åŸå› :\n`;
                        details += `1. æœåŠ¡å™¨å®•æœºæˆ–æœªå¯åŠ¨\n`;
                        details += `2. ç½‘ç»œé˜²ç«å¢™é˜»æ­¢è¿æ¥\n`;
                        details += `3. æœåŠ¡å™¨é…ç½®é”™è¯¯\n`;
                        
                        this.errors.push('æœåŠ¡å™¨ç½‘ç»œä¸å¯è¾¾');
                        this.recommendations.push('æ£€æŸ¥æœåŠ¡å™¨çŠ¶æ€å’Œç½‘ç»œé…ç½®');
                        
                        return { ping: { status: 'error', details } };
                    }
                }
            }
            
            analyzeFaults() {
                let faultAnalysis = '';
                
                if (this.failurePoint) {
                    faultAnalysis += `ğŸ”´ å‘ç°æ•…éšœç‚¹: ${this.failurePoint}\n\n`;
                    
                    switch(this.failurePoint) {
                        case 'DNSè§£æé˜¶æ®µ':
                            faultAnalysis += `ğŸ“Œ å…·ä½“é—®é¢˜: åŸŸåæ— æ³•è§£æåˆ°IPåœ°å€\n`;
                            faultAnalysis += `ğŸ’¡ è§£å†³æ–¹æ¡ˆ:\n`;
                            faultAnalysis += `1. æ£€æŸ¥åŸŸåæ‹¼å†™\n`;
                            faultAnalysis += `2. ç¡®è®¤åŸŸåæ˜¯å¦å·²æ³¨å†Œ\n`;
                            faultAnalysis += `3. æ£€æŸ¥DNSæœåŠ¡å™¨é…ç½®\n`;
                            break;
                            
                        case 'ç½‘ç»œè¿æ¥é˜¶æ®µ':
                            faultAnalysis += `ğŸ“Œ å…·ä½“é—®é¢˜: æœåŠ¡å™¨ç½‘ç»œä¸å¯è¾¾\n`;
                            faultAnalysis += `ğŸ’¡ è§£å†³æ–¹æ¡ˆ:\n`;
                            faultAnalysis += `1. æ£€æŸ¥æœåŠ¡å™¨æ˜¯å¦åœ¨çº¿\n`;
                            faultAnalysis += `2. æ£€æŸ¥é˜²ç«å¢™è®¾ç½®\n`;
                            faultAnalysis += `3. æµ‹è¯•ç½‘ç»œè·¯ç”±\n`;
                            break;
                            
                        case 'HTTPæœåŠ¡é˜¶æ®µ':
                            faultAnalysis += `ğŸ“Œ å…·ä½“é—®é¢˜: WebæœåŠ¡ä¸å¯ç”¨\n`;
                            faultAnalysis += `ğŸ’¡ è§£å†³æ–¹æ¡ˆ:\n`;
                            faultAnalysis += `1. æ£€æŸ¥WebæœåŠ¡å™¨çŠ¶æ€\n`;
                            faultAnalysis += `2. æŸ¥çœ‹æœåŠ¡å™¨é”™è¯¯æ—¥å¿—\n`;
                            faultAnalysis += `3. æ£€æŸ¥ç«¯å£80/443æ˜¯å¦å¼€æ”¾\n`;
                            break;
                            
                        case 'SSLè¯ä¹¦é˜¶æ®µ':
                            faultAnalysis += `ğŸ“Œ å…·ä½“é—®é¢˜: HTTPSè¯ä¹¦æœ‰é—®é¢˜\n`;
                            faultAnalysis += `ğŸ’¡ è§£å†³æ–¹æ¡ˆ:\n`;
                            faultAnalysis += `1. æ£€æŸ¥SSLè¯ä¹¦æœ‰æ•ˆæœŸ\n`;
                            faultAnalysis += `2. ç¡®ä¿è¯ä¹¦é“¾å®Œæ•´\n`;
                            faultAnalysis += `3. æ›´æ–°è¯ä¹¦é…ç½®\n`;
                            break;
                    }
                    
                } else if (this.errors.length > 0) {
                    faultAnalysis += `ğŸŸ¡ å‘ç°æ½œåœ¨é—®é¢˜\n`;
                    this.errors.forEach(error => {
                        faultAnalysis += `â€¢ ${error}\n`;
                    });
                    
                } else {
                    faultAnalysis = `âœ… åŸŸåçŠ¶æ€æ­£å¸¸ï¼Œæ‰€æœ‰è®¿é—®æ­¥éª¤å‡å¯æ­£å¸¸å·¥ä½œ\n`;
                }
                
                this.faultAnalysis = faultAnalysis;
            }
            
            displayResults() {
                const container = document.getElementById('resultsContainer');
                
                const totalTests = Object.keys(this.results).length;
                const successTests = Object.values(this.results).filter(r => r.status === 'success').length;
                const errorTests = Object.values(this.results).filter(r => r.status === 'error').length;
                const warningTests = Object.values(this.results).filter(r => r.status === 'warning').length;
                
                let summaryHtml = `
                    <div class="summary">
                        <h3>ğŸ“Š è¯Šæ–­æŠ¥å‘Šæ‘˜è¦</h3>
                        <p><strong>è¯Šæ–­åŸŸå:</strong> ${this.domain}</p>
                        <p><strong>è¯Šæ–­æ—¶é—´:</strong> ${new Date().toLocaleString()}</p>
                        <p><strong>æ£€æµ‹é¡¹ç›®:</strong> ${totalTests}é¡¹</p>
                        <p><strong>é€šè¿‡:</strong> ${successTests}é¡¹ | <strong>è­¦å‘Š:</strong> ${warningTests}é¡¹ | <strong>é”™è¯¯:</strong> ${errorTests}é¡¹</p>
                `;
                
                if (this.failurePoint) {
                    summaryHtml += `<p>ğŸ”´ å‘ç°æ•…éšœç‚¹: ${this.failurePoint}</p>`;
                } else if (this.errors.length === 0 && warningTests === 0) {
                    summaryHtml += `<p>ğŸ‰ åŸŸåçŠ¶æ€ä¼˜ç§€ï¼Œæ‰€æœ‰æ£€æµ‹é¡¹ç›®æ­£å¸¸</p>`;
                } else if (this.errors.length > 0) {
                    summaryHtml += `<p>ğŸ”´ å‘ç°${this.errors.length}ä¸ªä¸¥é‡é—®é¢˜ï¼Œéœ€è¦ç«‹å³å¤„ç†</p>`;
                } else if (warningTests > 0) {
                    summaryHtml += `<p>ğŸŸ¡ å‘ç°${warningTests}ä¸ªè­¦å‘Šé¡¹ç›®ï¼Œå»ºè®®ä¼˜åŒ–</p>`;
                }
                
                summaryHtml += `</div>`;
                
                // æ•…éšœè·Ÿè¸ªæ­¥éª¤
                let stepsHtml = '';
                if (this.steps.length > 0) {
                    stepsHtml = `
                        <div class="step-tracking">
                            <h3>ğŸ” æ•…éšœè·Ÿè¸ªæ­¥éª¤</h3>
                            <div class="step-list">
                    `;
                    
                    this.steps.forEach((step, index) => {
                        const isCurrent = index === this.steps.length - 1 && step.status === 'pending';
                        const stepClass = isCurrent ? 'current' : step.status;
                        const duration = step.endTime ? `(${step.endTime - step.startTime}ms)` : '';
                        
                        stepsHtml += `
                            <div class="step ${stepClass}">
                                <div class="step-number">${step.id}</div>
                                <div class="step-content">
                                    <div class="step-title">${step.title}</div>
                                    <div class="step-description">${step.description}</div>
                                    ${step.error ? `<div class="step-time" style="color:#ef4444;">é”™è¯¯: ${step.error}</div>` : ''}
                                    ${duration ? `<div class="step-time">${duration}</div>` : ''}
                                </div>
                            </div>
                        `;
                    });
                    
                    stepsHtml += `</div>`;
                    
                    if (this.failurePoint) {
                        stepsHtml += `
                            <div style="margin-top: 20px; padding: 15px; background: #fee2e2; border-radius: 8px;">
                                <strong style="color:#991b1b;">ğŸš¨ æ•…éšœç‚¹å®šä½:</strong> ${this.failurePoint}
                                <div style="margin-top: 10px; font-size: 14px; color: #475569;">
                                    è®¿é—®è¿‡ç¨‹åœ¨æ­¤æ­¥éª¤ä¸­æ–­ï¼Œå¯¼è‡´ç½‘ç«™æ— æ³•æ‰“å¼€
                                </div>
                            </div>
                        `;
                    }
                    
                    stepsHtml += `</div>`;
                }
                
                // æ•…éšœåˆ†æ
                let faultHtml = '';
                if (this.faultAnalysis) {
                    faultHtml = `
                        <div class="test-item ${this.failurePoint ? 'error' : this.errors.length > 0 ? 'warning' : 'success'}">
                            <div class="test-header">
                                <div class="test-title">ğŸ“‹ æ•…éšœåŸå› åˆ†æ</div>
                                <div class="test-status status-${this.failurePoint ? 'error' : this.errors.length > 0 ? 'warning' : 'success'}">
                                    ${this.failurePoint ? 'å‘ç°æ•…éšœ' : this.errors.length > 0 ? 'éœ€è¦ä¼˜åŒ–' : 'æ­£å¸¸'}
                                </div>
                            </div>
                            <div class="test-details">${this.faultAnalysis}</div>
                        </div>
                    `;
                }
                
                // é”™è¯¯åˆ—è¡¨
                let errorsHtml = '';
                if (this.errors.length > 0) {
                    errorsHtml = `
                        <div class="error-list">
                            <h3>âŒ å‘ç°çš„é—®é¢˜</h3>
                            ${this.errors.map(error => `<div class="error-item">${error}</div>`).join('')}
                        </div>
                    `;
                }
                
                // å»ºè®®åˆ—è¡¨
                let recommendationsHtml = '';
                if (this.recommendations.length > 0) {
                    recommendationsHtml = `
                        <div class="recommendations">
                            <h3>ğŸ’¡ ä¼˜åŒ–å»ºè®®</h3>
                            ${this.recommendations.map(rec => `<div>â€¢ ${rec}</div>`).join('')}
                        </div>
                    `;
                }
                
                // è¯¦ç»†ç»“æœ
                let detailsHtml = '';
                const testOrder = ['dns', 'ping', 'http', 'ssl', 'whois'];
                
                testOrder.forEach(key => {
                    const result = this.results[key];
                    if (result) {
                        const statusClass = result.status;
                        const statusText = result.status === 'success' ? 'é€šè¿‡' : 
                                        result.status === 'error' ? 'å¤±è´¥' : 'è­¦å‘Š';
                        
                        const testNames = {
                            dns: 'ğŸŒ DNSè§£ææ£€æµ‹',
                            ping: 'ğŸ“¡ ç½‘ç»œè¿é€šæ€§æµ‹è¯•',
                            http: 'ğŸ”— HTTP/HTTPSæ£€æµ‹',
                            ssl: 'ğŸ”’ SSLè¯ä¹¦æ£€æµ‹',
                            whois: 'ğŸ“‹ WHOISä¿¡æ¯æŸ¥è¯¢'
                        };
                        
                        detailsHtml += `
                            <div class="test-item ${statusClass}">
                                <div class="test-header">
                                    <div class="test-title">${testNames[key]}</div>
                                    <div class="test-status status-${statusClass}">${statusText}</div>
                                </div>
                                <div class="test-details">${result.details}</div>
                            </div>
                        `;
                    }
                });
                
                container.innerHTML = summaryHtml + stepsHtml + faultHtml + errorsHtml + recommendationsHtml + detailsHtml;
            }
        }
        
        const diagnostic = new ProfessionalDomainDiagnostic();
        
        async function startDiagnosis() {
            const domain = document.getElementById('domainInput').value.trim();
            
            if (!domain) {
                document.getElementById('errorMessage').textContent = 'è¯·è¾“å…¥è¦è¯Šæ–­çš„åŸŸå';
                document.getElementById('errorMessage').style.display = 'block';
                return;
            }
            
            const domainRegex = /^(?!:\/\/)([a-zA-Z0-9-]+\.)+[a-zA-Z]{2,}$/;
            if (!domainRegex.test(domain)) {
                document.getElementById('errorMessage').textContent = 'è¯·è¾“å…¥æœ‰æ•ˆçš„åŸŸåï¼ˆå¦‚ï¼šexample.comï¼‰';
                document.getElementById('errorMessage').style.display = 'block';
                return;
            }
            
            document.getElementById('errorMessage').style.display = 'none';
            await diagnostic.startDiagnosis(domain);
        }
        
        document.getElementById('domainInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') startDiagnosis();
        });
        
        window.addEventListener('DOMContentLoaded', () => {
            setTimeout(startDiagnosis, 500);
        });
    </script>
</body>
</html>
